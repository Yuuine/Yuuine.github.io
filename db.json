{"meta":{"version":1,"warehouse":"6.0.0"},"models":{"Asset":[{"_id":"themes/ayer/source/404.html","path":"404.html","modified":0,"renderable":1},{"_id":"themes/ayer/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"themes/ayer/source/css/clipboard.styl","path":"css/clipboard.styl","modified":0,"renderable":1},{"_id":"themes/ayer/source/css/custom.styl","path":"css/custom.styl","modified":0,"renderable":1},{"_id":"themes/ayer/source/dist/main.css","path":"dist/main.css","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/404.jpg","path":"images/404.jpg","modified":0,"renderable":1},{"_id":"themes/ayer/source/dist/main.js","path":"dist/main.js","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/cover1.jpg","path":"images/cover1.jpg","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/beian.png","path":"images/beian.png","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/cover4.jpg","path":"images/cover4.jpg","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/cover2.jpg","path":"images/cover2.jpg","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/cover3.jpg","path":"images/cover3.jpg","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/cover5.jpg","path":"images/cover5.jpg","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/cover6.jpg","path":"images/cover6.jpg","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/cover7.jpg","path":"images/cover7.jpg","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/forkme.png","path":"images/forkme.png","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/github.png","path":"images/github.png","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/gitee.png","path":"images/gitee.png","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/hexo-tag-chart.png","path":"images/hexo-tag-chart.png","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/mouse.cur","path":"images/mouse.cur","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/hexo.png","path":"images/hexo.png","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/yuuine-2.svg","path":"images/yuuine-2.svg","modified":0,"renderable":1},{"_id":"themes/ayer/source/js/busuanzi-2.3.pure.min.js","path":"js/busuanzi-2.3.pure.min.js","modified":0,"renderable":1},{"_id":"themes/ayer/source/js/clickBoom1.js","path":"js/clickBoom1.js","modified":0,"renderable":1},{"_id":"themes/ayer/source/js/clickBoom2.js","path":"js/clickBoom2.js","modified":0,"renderable":1},{"_id":"themes/ayer/source/js/clickLove.js","path":"js/clickLove.js","modified":0,"renderable":1},{"_id":"themes/ayer/source/js/lazyload.min.js","path":"js/lazyload.min.js","modified":0,"renderable":1},{"_id":"themes/ayer/source/js/dz.js","path":"js/dz.js","modified":0,"renderable":1},{"_id":"themes/ayer/source/js/jquery-3.6.0.min.js","path":"js/jquery-3.6.0.min.js","modified":0,"renderable":1},{"_id":"themes/ayer/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/ayer/source/js/tocbot.min.js","path":"js/tocbot.min.js","modified":0,"renderable":1},{"_id":"themes/ayer/source/css/fonts/remixicon.css","path":"css/fonts/remixicon.css","modified":0,"renderable":1},{"_id":"themes/ayer/source/css/fonts/remixicon.eot","path":"css/fonts/remixicon.eot","modified":0,"renderable":1},{"_id":"themes/ayer/source/css/fonts/remixicon.svg","path":"css/fonts/remixicon.svg","modified":0,"renderable":1},{"_id":"themes/ayer/source/css/fonts/remixicon.ttf","path":"css/fonts/remixicon.ttf","modified":0,"renderable":1},{"_id":"themes/ayer/source/css/fonts/remixicon.woff","path":"css/fonts/remixicon.woff","modified":0,"renderable":1},{"_id":"themes/ayer/source/css/fonts/remixicon.woff2","path":"css/fonts/remixicon.woff2","modified":0,"renderable":1}],"Cache":[{"_id":"source/about/index.md","hash":"85cdd2fc318e9b0393ae3ded90036961afbee0ba","modified":1766823332154},{"_id":"source/categories/index.md","hash":"b42a7b4d2a950938123d0bf50da97a9c4db70d94","modified":1766827797510},{"_id":"source/tags/index.md","hash":"0a8f388cf1508620a79f17aa29bc9fedba3b66b9","modified":1766823497077},{"_id":"source/_posts/RAG/introduceRAG.md","hash":"faddea4762daf303bcb25ee12b56da57f4c912b5","modified":1766844888408},{"_id":"source/_posts/Java/collection/arraylist-source-code.md","hash":"b8570a374f145499e2d26e11dcea6778c02b2959","modified":1766845305716},{"_id":"themes/ayer/.stylintrc","hash":"eec4e824067be1a223745ca426aa367c8d482673","modified":1766846684831},{"_id":"themes/ayer/_config.yml","hash":"85243d716d132ed47aae1cb8144a7ab91a2ddb05","modified":1766846514461},{"_id":"themes/ayer/index.js","hash":"a144d64baec7130267f64272fb256a9be3aa7cd5","modified":1766846669903},{"_id":"themes/ayer/languages/de.yml","hash":"2b7fa47fbe06f6928a43ea3b345ab3aeaa2cee81","modified":1766846514863},{"_id":"themes/ayer/languages/default.yml","hash":"1853255c243858cf9d26a589d7d26571e11ed5d1","modified":1766846514230},{"_id":"themes/ayer/languages/en.yml","hash":"1853255c243858cf9d26a589d7d26571e11ed5d1","modified":1766846514820},{"_id":"themes/ayer/languages/es.yml","hash":"fc27661276313c1c539252517d664359cb286f8a","modified":1766846514926},{"_id":"themes/ayer/languages/fr.yml","hash":"3dac4d53b9b2a1b10c0273ce7472b2e76576dc5a","modified":1766846514892},{"_id":"themes/ayer/languages/ko.yml","hash":"00db39dd43875774088511b4d467dcb71f1ce8ac","modified":1766846514646},{"_id":"themes/ayer/languages/ja.yml","hash":"aea06ea7bcb439d2b84501924cdd092293ee891a","modified":1766846514707},{"_id":"themes/ayer/languages/nl.yml","hash":"d619955fd9659a209c58f696ee2160dfe8c6ac41","modified":1766846514804},{"_id":"themes/ayer/languages/no.yml","hash":"fa4d2da9bb00ad0febc631afaf17f76aaa17e950","modified":1766846514734},{"_id":"themes/ayer/languages/pt.yml","hash":"fa0b3a4a01a0493f3ef402039e394a291a1251fd","modified":1766846514444},{"_id":"themes/ayer/languages/ru.yml","hash":"45edcadb57176d0b11a839055df1964da8ca08f9","modified":1766846514390},{"_id":"themes/ayer/languages/vi.yml","hash":"20f25fe0e9017d530a771687fe9d21353e034fff","modified":1766846514545},{"_id":"themes/ayer/languages/zh-CN.yml","hash":"edf1f8c164f3d166f94e213148e984fdfc3a7c85","modified":1766846514503},{"_id":"themes/ayer/languages/zh-TW.yml","hash":"750fba5314d340ddb00812fc17a608a084f04462","modified":1766846514270},{"_id":"themes/ayer/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1766846514339},{"_id":"themes/ayer/layout/index.ejs","hash":"c40a98c0a6f55c27959e44c9e8e4f2619fc2ad3f","modified":1766846514259},{"_id":"themes/ayer/layout/friends.ejs","hash":"2a4c0bfdf189ebae720f1325786a87c7cac51d37","modified":1766846514300},{"_id":"themes/ayer/layout/layout.ejs","hash":"ad2222b1819f763cd981f72b8204a19cb0fa75ae","modified":1766846514229},{"_id":"themes/ayer/layout/page.ejs","hash":"75879224e47b3329d7accfc2403580a2412dce25","modified":1766846514388},{"_id":"themes/ayer/layout/categories.ejs","hash":"b2deae0c31dd7fbf42a124db1b4c8c28d435c8e5","modified":1766846514857},{"_id":"themes/ayer/layout/plain-page.ejs","hash":"d351ff4aadd020a1960cc00f17fdd91a17e0cc54","modified":1766846514811},{"_id":"themes/ayer/scripts/default_config.js","hash":"617c2614d8bd8ffda2f2f84ab54fb18866e39b33","modified":1766848156033},{"_id":"themes/ayer/layout/tags.ejs","hash":"e7c9f93c6f7041a7d2aa95e85cc131b22aa426b7","modified":1766846514494},{"_id":"themes/ayer/source/404.html","hash":"fdcb196962eea912cf0a0552ec26a8cb13dd3cae","modified":1766846514501},{"_id":"themes/ayer/source/favicon.ico","hash":"d31e916fc2cd23745fbfb4e214922d6ee57792e8","modified":1766846514269},{"_id":"themes/ayer/source-src/main.js","hash":"fcb7c6c5ffcfd72ba9bd55b475af8a0e74484634","modified":1766848156864},{"_id":"themes/ayer/layout/post.ejs","hash":"75879224e47b3329d7accfc2403580a2412dce25","modified":1766846514544},{"_id":"themes/ayer/layout/_partial/ads.ejs","hash":"2be035aeef82265c5b0cb6aec6f4135ad1e0aa75","modified":1766846514772},{"_id":"themes/ayer/layout/_partial/after-footer.ejs","hash":"ec2dd8a5e55b99350d7606a4f4ba0918fd656116","modified":1766846514647},{"_id":"themes/ayer/layout/_partial/archive-post.ejs","hash":"6b3e77cdbf8271c2a22b839608cccaa651f84e93","modified":1766846514774},{"_id":"themes/ayer/layout/_partial/article.ejs","hash":"9ef0ed563dd6e3277534f9601ab290b72b3dc42b","modified":1766846514854},{"_id":"themes/ayer/layout/_partial/archive.ejs","hash":"1da014dd52294e132bc91eb2f45f67264a41e059","modified":1766846514301},{"_id":"themes/ayer/layout/_partial/ayer.ejs","hash":"84f5c967f5019f4964711f3edd408a7503702e58","modified":1766846514730},{"_id":"themes/ayer/layout/_partial/baidu-analytics.ejs","hash":"155327c23607f69989b58845f24d842a54e504b8","modified":1766846514725},{"_id":"themes/ayer/layout/_partial/broadcast.ejs","hash":"21fadeb390cff713fd432d0565bb901f8caff0c0","modified":1766846514886},{"_id":"themes/ayer/layout/_partial/footer.ejs","hash":"033fe5d56ecba3fc4ff9cffe0bcc0c62d01f883c","modified":1766846514208},{"_id":"themes/ayer/layout/_partial/head.ejs","hash":"38abac221b79d83fd8d3ec8ee0fba55ef162d148","modified":1766846514436},{"_id":"themes/ayer/layout/_partial/google-analytics.ejs","hash":"1a9b8574d4341354ed00127ffb873c80ac1beee9","modified":1766846514441},{"_id":"themes/ayer/layout/_partial/float-btns.ejs","hash":"b2fc5726168f012bc61845f33a46404ff4065947","modified":1766846514709},{"_id":"themes/ayer/layout/_partial/katex.ejs","hash":"bef830bc48db44c19bfa922d8ed5f6ee1e924ea7","modified":1766846514541},{"_id":"themes/ayer/layout/_partial/lock.ejs","hash":"72ec0a339f98399c5141f4b3aca4cc8e8310f03a","modified":1766846514386},{"_id":"themes/ayer/layout/_partial/mathjax.ejs","hash":"4d6b2bbe0d50f609a9d6e5d646d07f7ab29e8c66","modified":1766846514808},{"_id":"themes/ayer/layout/_partial/modal.ejs","hash":"b9caece8b5fb47e250c67f6f80f101f08d04eba9","modified":1766846514489},{"_id":"themes/ayer/layout/_partial/music.ejs","hash":"4a67b36cadf2661a5579a454b7d6e0be34e7a0d4","modified":1766846514261},{"_id":"themes/ayer/layout/_partial/sidebar.ejs","hash":"b7efb7f2b300de23d12ef310d710d809d979f4fd","modified":1766846514922},{"_id":"themes/ayer/layout/_partial/viewer.ejs","hash":"ba0639363016f5badd13fefd000ef967c6a4e47b","modified":1766846514335},{"_id":"themes/ayer/scripts/events/index.js","hash":"f3a5d9bda901565e3c302bcb5ed716b6d006089e","modified":1766848156041},{"_id":"themes/ayer/scripts/filters/index.js","hash":"e0c3b821ecd1cb614569282fb4f6e6f555545f8b","modified":1766848156043},{"_id":"themes/ayer/scripts/helpers/ayer-plus-vendors.js","hash":"611f3bcd8220312f92c11fa6a5dad02f011068d2","modified":1766848156044},{"_id":"themes/ayer/scripts/filters/meta_generator.js","hash":"46f6461a2bdc509837c36ede4d32c8b12e3d49b9","modified":1766848156030},{"_id":"themes/ayer/scripts/lib/core.js","hash":"00509e97554914e5b0a20e0843dc90bcf53461aa","modified":1766848156035},{"_id":"themes/ayer/scripts/helpers/wordcount.js","hash":"2014b5c5053ad737887b61014a045cc1b08799cd","modified":1766848156031},{"_id":"themes/ayer/scripts/utils/object.js","hash":"d798779ec79a53ce04b8ac79efd5d064981d95bd","modified":1766848156037},{"_id":"themes/ayer/scripts/utils/join-path.js","hash":"ec068c699155565aea4aa4ab55d8a10b2947a114","modified":1766848156027},{"_id":"themes/ayer/source/css/custom.styl","hash":"32990e811ea6fba84673b6d7175c88a3b890b109","modified":1766846514632},{"_id":"themes/ayer/source/css/clipboard.styl","hash":"145f335d6369744a75c2c39a50f63a88f720f85b","modified":1766846514792},{"_id":"themes/ayer/source/dist/main.css","hash":"1f49cde949291ed86277d30721a7e728a4f8671a","modified":1766846514410},{"_id":"themes/ayer/source/dist/main.js","hash":"4338ca7a7bc35ee139016c91d4746643a3ee01c8","modified":1766846514466},{"_id":"themes/ayer/source/images/404.jpg","hash":"4f36a8d378712427cded03f5166949f5e0ba754c","modified":1766846741478},{"_id":"themes/ayer/source/images/beian.png","hash":"29c400bc3b89f6085766dac4e0330ded5cb73d52","modified":1766846741479},{"_id":"themes/ayer/source/images/cover7.jpg","hash":"573bff6899d2d9c5bcba0dc9c60cd1ec9eb8b029","modified":1766846514803},{"_id":"themes/ayer/source/images/forkme.png","hash":"99c3e21a169421e4f249befb428396c729863a75","modified":1766846514733},{"_id":"themes/ayer/source/images/github.png","hash":"4853ff37f9d859e7faa77675632a73f8ef089a15","modified":1766846514468},{"_id":"themes/ayer/source/images/gitee.png","hash":"250da578e0bd1393f22737f58d0fbae95119e527","modified":1766846514342},{"_id":"themes/ayer/source/images/hexo-tag-chart.png","hash":"6db432aae30556d151c2fd2c1d11015d9309ba81","modified":1766846741495},{"_id":"themes/ayer/source/images/mouse.cur","hash":"c1ffe93a6ba0d25ef06bb3d097560762e4807593","modified":1766846741497},{"_id":"themes/ayer/source/images/hexo.png","hash":"6b0315fba8a8f496491079b361e2fb5253e19a04","modified":1766846741497},{"_id":"themes/ayer/source/images/yuuine-2.svg","hash":"e354a599ffea42ab6fce02209e95b42e374796b0","modified":1766846514413},{"_id":"themes/ayer/source-src/js/share.js","hash":"7c105c427d472d84bee2ef3f0a61efa4ac6d564f","modified":1766848156867},{"_id":"themes/ayer/source-src/js/ayer.js","hash":"a3d349fb8af029e710d064c15373163680da2d39","modified":1766848156905},{"_id":"themes/ayer/source/js/busuanzi-2.3.pure.min.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1766846514263},{"_id":"themes/ayer/source/js/clickBoom1.js","hash":"c97ea1f120dba2c6804d0420186ef5d6f2419b7c","modified":1766846514731},{"_id":"themes/ayer/source/js/clickBoom2.js","hash":"2bc7267652ec49cea5dc3a8bd470c7d5ec57c721","modified":1766846514464},{"_id":"themes/ayer/source/js/clickLove.js","hash":"a35dfb7ff19796c005ee30b55fd95e39d6d59a89","modified":1766846514789},{"_id":"themes/ayer/source/js/lazyload.min.js","hash":"d9bc50752cd7e331dbd0a833386838397c9a079f","modified":1766846514547},{"_id":"themes/ayer/source/js/dz.js","hash":"079ae73e2e396c2e00919a50a6fe0d064f99303a","modified":1766846514666},{"_id":"themes/ayer/source/js/search.js","hash":"6d5c093d12e922ad204dab1723b786c35847bf1b","modified":1766846514593},{"_id":"themes/ayer/source/js/tocbot.min.js","hash":"bae97e8a24a05a99335f8e725641c8ca9c50502a","modified":1766846514408},{"_id":"themes/ayer/source-src/css/_darkmode.styl","hash":"eda0bf55d64f2cdeb75f9489818c34635bc85c00","modified":1766848156861},{"_id":"themes/ayer/source-src/css/_extend.styl","hash":"996ed7faa5ebf69af1f14f90f774dc7a53774537","modified":1766848156928},{"_id":"themes/ayer/source-src/css/_normalize.styl","hash":"b90386215434cc76549c046e7f67392049492a6a","modified":1766848156841},{"_id":"themes/ayer/source-src/css/_mixins.styl","hash":"e4804d78ded3714495f8ac9cebdbd2871ed97549","modified":1766848156891},{"_id":"themes/ayer/source-src/css/_remixicon.styl","hash":"6e7671af612868b750f1dc195f2e7c1c34931800","modified":1766848156931},{"_id":"themes/ayer/source-src/css/_variables.styl","hash":"2fdb4425b6213fed28921f53179e825aee0500cf","modified":1766848156894},{"_id":"themes/ayer/source-src/css/style.styl","hash":"dd5f5d0fef358ea1eba3f782458f72e13f764bba","modified":1766848156839},{"_id":"themes/ayer/layout/_partial/post/albums.ejs","hash":"f4cfbabca9f59a9e5aa457a6f2a9cf6f56cd22b3","modified":1766846514387},{"_id":"themes/ayer/layout/_partial/post/author.ejs","hash":"0e6c2862d75e5b21faf28a5cc3310d3515340287","modified":1766846514539},{"_id":"themes/ayer/layout/_partial/post/category.ejs","hash":"89cb32e8d98bad81d3ef33377212e9b253699d3d","modified":1766846514884},{"_id":"themes/ayer/layout/_partial/post/busuanzi.ejs","hash":"895293405b2b3b19fe97d79f4a25e16bea153ae8","modified":1766846514923},{"_id":"themes/ayer/layout/_partial/post/clipboard.ejs","hash":"55f2fafe9c6a151eeee39d1a2556742ebe89b2a2","modified":1766846514662},{"_id":"themes/ayer/layout/_partial/post/date.ejs","hash":"947f513f7a85fbcf085624e46dc2ae6de8185eec","modified":1766846514591},{"_id":"themes/ayer/layout/_partial/post/gitalk.ejs","hash":"9f0250bc192a59a8577ea3048c8f5eef91ac10ef","modified":1766846514491},{"_id":"themes/ayer/layout/_partial/post/justifiedGallery.ejs","hash":"a313df6a014a0f2ba6b869dabc56bacb8ff6324d","modified":1766846514588},{"_id":"themes/ayer/layout/_partial/post/nav.ejs","hash":"a73010cbbc463089a1376889850fb0890143c988","modified":1766846514882},{"_id":"themes/ayer/layout/_partial/post/gallery.ejs","hash":"6f78a49edc91f230b0a838c77630e9671d8d6089","modified":1766846514855},{"_id":"themes/ayer/layout/_partial/post/tag.ejs","hash":"694b5101bcc44c9f9c1cc62e5ad2fdfb4b7c7a07","modified":1766846514664},{"_id":"themes/ayer/layout/_partial/post/search.ejs","hash":"47c818c236b063d6ce0c41e0824f9f10a3521414","modified":1766846514262},{"_id":"themes/ayer/layout/_partial/post/share.ejs","hash":"9a978d55358878c97186ed010e536e1b314adb35","modified":1766846514728},{"_id":"themes/ayer/layout/_partial/post/title.ejs","hash":"e55c57b8cb8c8acf0ed998ea31c2fbc1d6256027","modified":1766846514439},{"_id":"themes/ayer/layout/_partial/post/tocbot.ejs","hash":"17ac504f2a6d561765046a0ba19dcce504104517","modified":1766846514210},{"_id":"themes/ayer/layout/_partial/post/topping.ejs","hash":"de2c50fb5b7a816287c6d048a2a22ae9c29abcdd","modified":1766846514810},{"_id":"themes/ayer/layout/_partial/post/twikoo.ejs","hash":"1e591e7b71880ca0a1dd9ab9913aa67fdd91633a","modified":1766846514337},{"_id":"themes/ayer/layout/_partial/post/valine.ejs","hash":"d5b568a3554f0d6572e7b232b8a0ab3ea81a1845","modified":1766846514299},{"_id":"themes/ayer/layout/_partial/post/word.ejs","hash":"5b785368a0a6f3b5538aa1b9e7574daa8dfb0df6","modified":1766846514773},{"_id":"themes/ayer/scripts/events/lib/hello.js","hash":"058c73fa3900d143affb9cc7ea0b2105d3925915","modified":1766848156038},{"_id":"themes/ayer/scripts/events/lib/merge-configs.js","hash":"734aac9a53cf168ee51482b02b75954a2a3df150","modified":1766848156028},{"_id":"themes/ayer/source-src/css/_partial/albums.styl","hash":"5802253789028a4d9dac474168fc7132045e72ff","modified":1766848156871},{"_id":"themes/ayer/source-src/css/_partial/apple.styl","hash":"333f9e59dc6625c4dee126a1c1a9c25ce9292655","modified":1766848156903},{"_id":"themes/ayer/source-src/css/_partial/ads.styl","hash":"e3e533ac5b9b6c5ef7d3829c890aff42dc29cfc1","modified":1766848156906},{"_id":"themes/ayer/source-src/css/_partial/archive.styl","hash":"9dbb04cf0ae07b50acd6f343e673df215a3c868e","modified":1766848156854},{"_id":"themes/ayer/source-src/css/_partial/article.styl","hash":"659a35544b321a101f7cf114f0c9fdf2cc125625","modified":1766848156830},{"_id":"themes/ayer/source-src/css/_partial/articles.styl","hash":"ddbe833939180afdc832659c5cdad08f77ef4f46","modified":1766848156836},{"_id":"themes/ayer/source-src/css/_partial/ayer.styl","hash":"38187e5c88eaf1ea099f2ded56f1f60194c95ec4","modified":1766848156846},{"_id":"themes/ayer/source-src/css/_partial/categories.styl","hash":"cb3b1667c83182d6309e6d066f53f2771723729e","modified":1766848156897},{"_id":"themes/ayer/source-src/css/_partial/float.styl","hash":"b1abfdfd05e74745484f7e6d043ef2842b3f6b41","modified":1766848156865},{"_id":"themes/ayer/source-src/css/_partial/gallery.styl","hash":"f5eae1b0030cfd97f1646844c9d3f692dbb38946","modified":1766848156889},{"_id":"themes/ayer/source-src/css/_partial/footer.styl","hash":"ae22e9d1525f267be368359ed0096f26791b809e","modified":1766848156851},{"_id":"themes/ayer/source-src/css/_partial/gitalk.styl","hash":"0678e8b330daea56fa30d14e97de73289a7d6f22","modified":1766848156818},{"_id":"themes/ayer/source-src/css/_partial/friends.styl","hash":"10332c63736e4ce31353b7605012caf744a8286a","modified":1766848156915},{"_id":"themes/ayer/source-src/css/_partial/highlight.styl","hash":"1210f704aae34ef653e3a458cccb700b05353ea1","modified":1766848156934},{"_id":"themes/ayer/source-src/css/_partial/justifiedGallery.styl","hash":"9828c78fb59c3ea3de7cce2569313d12c4b1a6ff","modified":1766848156859},{"_id":"themes/ayer/source-src/css/_partial/layout.styl","hash":"d4613f176636cae6a4af6124863a176c32ea6471","modified":1766848156912},{"_id":"themes/ayer/source-src/css/_partial/lists.styl","hash":"dc45f8b1a5942d4d979fb0859bc47a86f73fe0a9","modified":1766848156849},{"_id":"themes/ayer/source-src/css/_partial/mobile.styl","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1766848156887},{"_id":"themes/ayer/source-src/css/_partial/navbar.styl","hash":"266df43ec4041226f1801719e873265b75fe6515","modified":1766848156856},{"_id":"themes/ayer/source-src/css/_partial/search.styl","hash":"3f2c7bd1371f6f25aec7c581dbae7b52f95ec4c6","modified":1766848156937},{"_id":"themes/ayer/source-src/css/_partial/pace.styl","hash":"bbda18c692fc66ae99e45347ff52c14e44a08e3b","modified":1766848156813},{"_id":"themes/ayer/source-src/css/_partial/reward.styl","hash":"924114f723a22dbb8970d023bc2e033141b3438d","modified":1766848156834},{"_id":"themes/ayer/source-src/css/_partial/share.styl","hash":"4a6e6ac9156553dd5cee1eeee8fdc6f1f8a5d117","modified":1766848156816},{"_id":"themes/ayer/source-src/css/_partial/totop.styl","hash":"b6010788be1d99a345abcf0cf9cdf0a564b90d3c","modified":1766848156910},{"_id":"themes/ayer/source-src/css/_partial/tag.styl","hash":"6072aa6bd16e0a1e75f0258d7b20587cab56fff8","modified":1766848156869},{"_id":"themes/ayer/source-src/css/_partial/tocbot.styl","hash":"130e29937aa750e63e8cf216934dbdd4ea95969f","modified":1766848156900},{"_id":"themes/ayer/source-src/css/_partial/sidebar.styl","hash":"cdc7bea47a768b18991decde0d38c554399621ee","modified":1766848156844},{"_id":"themes/ayer/source/images/cover2.jpg","hash":"f61dd08c95327468c5f6bc5175eff68d00f05b46","modified":1766846741481},{"_id":"themes/ayer/source/js/jquery-3.6.0.min.js","hash":"4cd5ddc413b3024d7b56331c0d0d0b2bd933f27f","modified":1766846514496},{"_id":"themes/ayer/source/css/fonts/remixicon.css","hash":"8b54eed3270fae6d5bde5b0a6b522a32b5bd39a0","modified":1766846514303},{"_id":"themes/ayer/source/css/fonts/remixicon.woff2","hash":"d83e667e2d8583bcd2d97b4ebe13ff1f147b947c","modified":1766846741477},{"_id":"themes/ayer/source/css/fonts/remixicon.woff","hash":"8d6a423fd373c0a1f45b927d37f8f932aaea21ec","modified":1766846741476},{"_id":"themes/ayer/source/images/cover6.jpg","hash":"a5b8a5dddff2607fee5fccf5fdef3b214a8468cc","modified":1766846741495},{"_id":"themes/ayer/source/images/cover1.jpg","hash":"e019fbed6158ae3e4ec3d255b41bddc1afcbfa90","modified":1766846514861},{"_id":"themes/ayer/source/images/cover3.jpg","hash":"7b4e7c9ce19ce5d5c1588b2567e88ecbb04370af","modified":1766846741483},{"_id":"themes/ayer/source/css/fonts/remixicon.eot","hash":"7e929b884b2201250fc49e8e79c3aba6cd9e4482","modified":1766846741471},{"_id":"themes/ayer/source/css/fonts/remixicon.ttf","hash":"7eba83fb4482a63f3b338ccb6dca312e8e95db7f","modified":1766846741474},{"_id":"themes/ayer/source/images/cover4.jpg","hash":"77040e609d2f1c60e00a8e47cb95b25bf7ff5b9c","modified":1766846741487},{"_id":"themes/ayer/source/images/cover5.jpg","hash":"1a2d6182d94b015a45fe4bf8e8a239dfcc0ef776","modified":1766846741493},{"_id":"themes/ayer/source/css/fonts/remixicon.svg","hash":"d5ab3ec2fd85b327b8c806228d2cd84b6d6b24c8","modified":1766846514816},{"_id":"public/categories/index.html","hash":"9d4c1208039c0eabea7f59d605a72812d94e59f4","modified":1766848325532},{"_id":"public/about/index.html","hash":"0e3707c90aa074f7849cb8071df143cf43af7326","modified":1766848325532},{"_id":"public/tags/index.html","hash":"6028e1c482c34a57762c50ddff882170a6aa7116","modified":1766848325532},{"_id":"public/Java/collection/index.html","hash":"f8abfcde8f33c3e5a715104d5fe208738a2f3226","modified":1766848325532},{"_id":"public/RAG/index.html","hash":"38cb7483199aac9b4b9cf885332f4b62070407b0","modified":1766848325532},{"_id":"public/archives/index.html","hash":"a079f7c8454568051d95464ed42e925966b6a307","modified":1766848325532},{"_id":"public/archives/2025/index.html","hash":"6daa5b0f8073cacc8490e57177a04c256e7343c4","modified":1766848325532},{"_id":"public/archives/2025/12/index.html","hash":"ae38e98ccbd5b09bada9415740c65eddc7aca0e1","modified":1766848325532},{"_id":"public/categories/Java/index.html","hash":"6a8d5035a5399b57e6b2cf78c5aee280ecde7aa3","modified":1766848325532},{"_id":"public/categories/RAG/index.html","hash":"eeb296b590ccc873994b8283c1bf615a05bdac75","modified":1766848325532},{"_id":"public/categories/Java/collection/index.html","hash":"ae197d8ef0639cd34165c2b2aa53bc51411880b4","modified":1766848325532},{"_id":"public/index.html","hash":"be02bcf299c022e1fec82957f3d43d8d4919b042","modified":1766848325532},{"_id":"public/tags/Java/index.html","hash":"547be0b84f7558a37215af3ed854d5d8810a551b","modified":1766848325532},{"_id":"public/tags/collection/index.html","hash":"f47d99717be25fd9cd7e2f9c606af0733dbc7a8e","modified":1766848325532},{"_id":"public/tags/RAG/index.html","hash":"a8c731a89a9cfdba24a9fe21455018d62e9ac8f8","modified":1766848325532},{"_id":"public/favicon.ico","hash":"d31e916fc2cd23745fbfb4e214922d6ee57792e8","modified":1766848325532},{"_id":"public/images/404.jpg","hash":"4f36a8d378712427cded03f5166949f5e0ba754c","modified":1766848325532},{"_id":"public/images/beian.png","hash":"29c400bc3b89f6085766dac4e0330ded5cb73d52","modified":1766848325532},{"_id":"public/images/forkme.png","hash":"99c3e21a169421e4f249befb428396c729863a75","modified":1766848325532},{"_id":"public/images/cover7.jpg","hash":"573bff6899d2d9c5bcba0dc9c60cd1ec9eb8b029","modified":1766848325532},{"_id":"public/images/github.png","hash":"4853ff37f9d859e7faa77675632a73f8ef089a15","modified":1766848325532},{"_id":"public/images/gitee.png","hash":"250da578e0bd1393f22737f58d0fbae95119e527","modified":1766848325532},{"_id":"public/images/hexo-tag-chart.png","hash":"6db432aae30556d151c2fd2c1d11015d9309ba81","modified":1766848325532},{"_id":"public/images/mouse.cur","hash":"c1ffe93a6ba0d25ef06bb3d097560762e4807593","modified":1766848325532},{"_id":"public/images/hexo.png","hash":"6b0315fba8a8f496491079b361e2fb5253e19a04","modified":1766848325532},{"_id":"public/images/yuuine-2.svg","hash":"e354a599ffea42ab6fce02209e95b42e374796b0","modified":1766848325532},{"_id":"public/css/clipboard.css","hash":"7990b92ffeda1b06b94b50140d9c95dac21bd418","modified":1766848325532},{"_id":"public/404.html","hash":"6ef9aef4552d1465c1351843586e521f9f70c775","modified":1766848325532},{"_id":"public/css/custom.css","hash":"58950a4f4cd82465f85428ec17b3bc05f8153b56","modified":1766848325532},{"_id":"public/dist/main.css","hash":"1f49cde949291ed86277d30721a7e728a4f8671a","modified":1766848325532},{"_id":"public/dist/main.js","hash":"436093b4310b4656fb1e60ae946d04b85d6b1fa5","modified":1766848325532},{"_id":"public/js/busuanzi-2.3.pure.min.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1766848325532},{"_id":"public/js/clickBoom1.js","hash":"afd4a981d3a56c40898248152009d478a3cd0d1e","modified":1766848325532},{"_id":"public/js/clickLove.js","hash":"9e8e79d69ad8338761272f86fe5cad0ad5e503cc","modified":1766848325532},{"_id":"public/js/clickBoom2.js","hash":"d3fe9e8c7046bec9745628f61d61e4102171ac2b","modified":1766848325532},{"_id":"public/js/lazyload.min.js","hash":"b801b3946fb9b72e03512c0663458e140e1fa77b","modified":1766848325532},{"_id":"public/js/dz.js","hash":"079ae73e2e396c2e00919a50a6fe0d064f99303a","modified":1766848325532},{"_id":"public/js/search.js","hash":"118be0e0918532ac1225f62e1a0a6f0673e0b173","modified":1766848325532},{"_id":"public/js/jquery-3.6.0.min.js","hash":"b82d238d4e31fdf618bae8ac11a6c812c03dd0d4","modified":1766848325532},{"_id":"public/js/tocbot.min.js","hash":"bae97e8a24a05a99335f8e725641c8ca9c50502a","modified":1766848325532},{"_id":"public/css/fonts/remixicon.css","hash":"be1956502b9cf5081091ff78d7f11cd7ea733be8","modified":1766848325532},{"_id":"public/images/cover2.jpg","hash":"f61dd08c95327468c5f6bc5175eff68d00f05b46","modified":1766848325532},{"_id":"public/css/fonts/remixicon.woff","hash":"8d6a423fd373c0a1f45b927d37f8f932aaea21ec","modified":1766848325532},{"_id":"public/css/fonts/remixicon.woff2","hash":"d83e667e2d8583bcd2d97b4ebe13ff1f147b947c","modified":1766848325532},{"_id":"public/images/cover6.jpg","hash":"a5b8a5dddff2607fee5fccf5fdef3b214a8468cc","modified":1766848325532},{"_id":"public/images/cover1.jpg","hash":"e019fbed6158ae3e4ec3d255b41bddc1afcbfa90","modified":1766848325532},{"_id":"public/images/cover3.jpg","hash":"7b4e7c9ce19ce5d5c1588b2567e88ecbb04370af","modified":1766848325532},{"_id":"public/css/fonts/remixicon.eot","hash":"7e929b884b2201250fc49e8e79c3aba6cd9e4482","modified":1766848325532},{"_id":"public/css/fonts/remixicon.ttf","hash":"7eba83fb4482a63f3b338ccb6dca312e8e95db7f","modified":1766848325532},{"_id":"public/images/cover4.jpg","hash":"77040e609d2f1c60e00a8e47cb95b25bf7ff5b9c","modified":1766848325532},{"_id":"public/images/cover5.jpg","hash":"1a2d6182d94b015a45fe4bf8e8a239dfcc0ef776","modified":1766848325532},{"_id":"public/css/fonts/remixicon.svg","hash":"d5ab3ec2fd85b327b8c806228d2cd84b6d6b24c8","modified":1766848325532}],"Category":[{"name":"Java","_id":"cuideyTbsvPYcPCgcgGqvpbSY"},{"name":"RAG","_id":"cuidJdx6lKUygRevtyUT1rud9"},{"name":"collection","parent":"cuideyTbsvPYcPCgcgGqvpbSY","_id":"cuidNpz3u01UfoQFYuOP1TQxi"}],"Data":[],"Page":[{"title":"categories","date":"2025-12-27T08:13:27.000Z","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2025-12-27 16:13:27\n---\n","updated":"2025-12-27T09:29:57.510Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cuidJYVDcSbJSJV9RzjiF3nfd","content":"","excerpt":"","more":""},{"title":"关于我","_content":"\n# 个人介绍","source":"about/index.md","raw":"---\ntitle: 关于我\n---\n\n# 个人介绍","date":"2025-12-27T08:15:32.154Z","updated":"2025-12-27T08:15:32.154Z","path":"about/index.html","comments":1,"layout":"page","_id":"cuidnr-j2FABR5_EQWSvzHtws","content":"<h1 id=\"个人介绍\"><a href=\"#个人介绍\" class=\"headerlink\" title=\"个人介绍\"></a>个人介绍</h1>","excerpt":"","more":"<h1 id=\"个人介绍\"><a href=\"#个人介绍\" class=\"headerlink\" title=\"个人介绍\"></a>个人介绍</h1>"},{"title":"tags","date":"2025-12-27T08:18:17.000Z","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2025-12-27 16:18:17\n---\n","updated":"2025-12-27T08:18:17.077Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cuidFZG5BRK-CKgXpOZFPZeWB","content":"","excerpt":"","more":""}],"Post":[{"title":"ArrayList 源码分析","date":"2025-12-27T09:07:20.000Z","_content":"\n## ArrayList 简介\n\n`ArrayList` 的底层是数组队列，相当于动态数组。与 Java 中的数组相比，它的容量能动态增长。在添加大量元素前，应用程序可以使用`ensureCapacity`操作来增加 `ArrayList` 实例的容量。这可以减少递增式再分配的数量。\n\n`ArrayList` 继承于 `AbstractList` ，实现了 `List`, `RandomAccess`, `Cloneable`, `java.io.Serializable` 这些接口。\n\n```java\n\npublic class ArrayList<E> extends AbstractList<E>\n        implements List<E>, RandomAccess, Cloneable, java.io.Serializable{\n\n  }\n```\n\n- `List` : 表明它是一个列表，支持添加、删除、查找等操作，并且可以通过下标进行访问。\n- `RandomAccess` ：这是一个标志接口，表明实现这个接口的 `List` 集合是支持 **快速随机访问** 的。在 `ArrayList` 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。\n- `Cloneable` ：表明它具有拷贝能力，可以进行深拷贝或浅拷贝操作。\n- `Serializable` : 表明它可以进行序列化操作，也就是可以将对象转换为字节流进行持久化存储或网络传输，非常方便。\n\n\n### ArrayList 和 Vector 的区别?（了解即可）\n\n- `ArrayList` 是 `List` 的主要实现类，底层使用 `Object[]`存储，适用于频繁的查找工作，线程不安全 。\n- `Vector` 是 `List` 的古老实现类，底层使用`Object[]` 存储，线程安全。\n\n### ArrayList 可以添加 null 值吗？\n\n`ArrayList` 中可以存储任何类型的对象，包括 `null` 值。不过，不建议向`ArrayList` 中添加 `null` 值， `null` 值无意义，会让代码难以维护比如忘记做判空处理就会导致空指针异常。\n\n示例代码：\n\n```java\nArrayList<String> listOfStrings = new ArrayList<>();\nlistOfStrings.add(null);\nlistOfStrings.add(\"java\");\nSystem.out.println(listOfStrings);\n```\n\n输出：\n\n```plain\n[null, java]\n```\n\n### Arraylist 与 LinkedList 区别?\n\n- **是否保证线程安全：** `ArrayList` 和 `LinkedList` 都是不同步的，也就是不保证线程安全；\n- **底层数据结构：** `ArrayList` 底层使用的是 **`Object` 数组**；`LinkedList` 底层使用的是 **双向链表** 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）\n- **插入和删除是否受元素位置的影响：**\n    - `ArrayList` 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行`add(E e)`方法的时候， `ArrayList` 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（`add(int index, E element)`），时间复杂度就为 O(n)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。\n    - `LinkedList` 采用链表存储，所以在头尾插入或者删除元素不受元素位置的影响（`add(E e)`、`addFirst(E e)`、`addLast(E e)`、`removeFirst()`、 `removeLast()`），时间复杂度为 O(1)，如果是要在指定位置 `i` 插入和删除元素的话（`add(int index, E element)`，`remove(Object o)`,`remove(int index)`）， 时间复杂度为 O(n) ，因为需要先移动到指定位置再插入和删除。\n- **是否支持快速随机访问：** `LinkedList` 不支持高效的随机元素访问，而 `ArrayList`（实现了 `RandomAccess` 接口） 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于`get(int index)`方法)。\n- **内存空间占用：** `ArrayList` 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。\n\n## ArrayList 核心源码解读\n\n这里以 JDK1.8 为例，分析一下 `ArrayList` 的底层源码。\n\n```java\npublic class ArrayList<E> extends AbstractList<E>\n        implements List<E>, RandomAccess, Cloneable, java.io.Serializable {\n    private static final long serialVersionUID = 8683452581122892189L;\n\n    /**\n     * 默认初始容量大小\n     */\n    private static final int DEFAULT_CAPACITY = 10;\n\n    /**\n     * 空数组（用于空实例）。\n     */\n    private static final Object[] EMPTY_ELEMENTDATA = {};\n\n    //用于默认大小空实例的共享空数组实例。\n    //我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。\n    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n\n    /**\n     * 保存ArrayList数据的数组\n     */\n    transient Object[] elementData; // non-private to simplify nested class access\n\n    /**\n     * ArrayList 所包含的元素个数\n     */\n    private int size;\n\n    /**\n     * 带初始容量参数的构造函数（用户可以在创建ArrayList对象时自己指定集合的初始大小）\n     */\n    public ArrayList(int initialCapacity) {\n        if (initialCapacity > 0) {\n            //如果传入的参数大于0，创建initialCapacity大小的数组\n            this.elementData = new Object[initialCapacity];\n        } else if (initialCapacity == 0) {\n            //如果传入的参数等于0，创建空数组\n            this.elementData = EMPTY_ELEMENTDATA;\n        } else {\n            //其他情况，抛出异常\n            throw new IllegalArgumentException(\"Illegal Capacity: \" +\n                    initialCapacity);\n        }\n    }\n\n    /**\n     * 默认无参构造函数\n     * DEFAULTCAPACITY_EMPTY_ELEMENTDATA 为0.初始化为10，也就是说初始其实是空数组 当添加第一个元素的时候数组容量才变成10\n     */\n    public ArrayList() {\n        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n    }\n\n    /**\n     * 构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。\n     */\n    public ArrayList(Collection<? extends E> c) {\n        //将指定集合转换为数组\n        elementData = c.toArray();\n        //如果elementData数组的长度不为0\n        if ((size = elementData.length) != 0) {\n            // 如果elementData不是Object类型数据（c.toArray可能返回的不是Object类型的数组所以加上下面的语句用于判断）\n            if (elementData.getClass() != Object[].class)\n                //将原来不是Object类型的elementData数组的内容，赋值给新的Object类型的elementData数组\n                elementData = Arrays.copyOf(elementData, size, Object[].class);\n        } else {\n            // 其他情况，用空数组代替\n            this.elementData = EMPTY_ELEMENTDATA;\n        }\n    }\n\n    /**\n     * 修改这个ArrayList实例的容量是列表的当前大小。 应用程序可以使用此操作来最小化ArrayList实例的存储。\n     */\n    public void trimToSize() {\n        modCount++;\n        if (size < elementData.length) {\n            elementData = (size == 0)\n                    ? EMPTY_ELEMENTDATA\n                    : Arrays.copyOf(elementData, size);\n        }\n    }\n//下面是ArrayList的扩容机制\n//ArrayList的扩容机制提高了性能，如果每次只扩充一个，\n//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。\n\n    /**\n     * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量\n     *\n     * @param minCapacity 所需的最小容量\n     */\n    public void ensureCapacity(int minCapacity) {\n        // 如果不是默认空数组，则minExpand的值为0；\n        // 如果是默认空数组，则minExpand的值为10\n        int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)\n                // 如果不是默认元素表，则可以使用任意大小\n                ? 0\n                // 如果是默认空数组，它应该已经是默认大小\n                : DEFAULT_CAPACITY;\n\n        // 如果最小容量大于已有的最大容量\n        if (minCapacity > minExpand) {\n            // 根据需要的最小容量，确保容量足够\n            ensureExplicitCapacity(minCapacity);\n        }\n    }\n\n\n    // 根据给定的最小容量和当前数组元素来计算所需容量。\n    private static int calculateCapacity(Object[] elementData, int minCapacity) {\n        // 如果当前数组元素为空数组（初始情况），返回默认容量和最小容量中的较大值作为所需容量\n        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n            return Math.max(DEFAULT_CAPACITY, minCapacity);\n        }\n        // 否则直接返回最小容量\n        return minCapacity;\n    }\n\n    // 确保内部容量达到指定的最小容量。\n    private void ensureCapacityInternal(int minCapacity) {\n        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));\n    }\n\n    //判断是否需要扩容\n    private void ensureExplicitCapacity(int minCapacity) {\n        modCount++;\n        // overflow-conscious code\n        if (minCapacity - elementData.length > 0)\n            //调用grow方法进行扩容，调用此方法代表已经开始扩容了\n            grow(minCapacity);\n    }\n\n    /**\n     * 要分配的最大数组大小\n     */\n    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n\n    /**\n     * ArrayList扩容的核心方法。\n     */\n    private void grow(int minCapacity) {\n        // oldCapacity为旧容量，newCapacity为新容量\n        int oldCapacity = elementData.length;\n        //将oldCapacity 右移一位，其效果相当于oldCapacity /2，\n        //我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，\n        int newCapacity = oldCapacity + (oldCapacity >> 1);\n        //然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，\n        if (newCapacity - minCapacity < 0)\n            newCapacity = minCapacity;\n        //再检查新容量是否超出了ArrayList所定义的最大容量，\n        //若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，\n        //如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Integer.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。\n        if (newCapacity - MAX_ARRAY_SIZE > 0)\n            newCapacity = hugeCapacity(minCapacity);\n        // minCapacity is usually close to size, so this is a win:\n        elementData = Arrays.copyOf(elementData, newCapacity);\n    }\n\n    //比较minCapacity和 MAX_ARRAY_SIZE\n    private static int hugeCapacity(int minCapacity) {\n        if (minCapacity < 0) // overflow\n            throw new OutOfMemoryError();\n        return (minCapacity > MAX_ARRAY_SIZE) ?\n                Integer.MAX_VALUE :\n                MAX_ARRAY_SIZE;\n    }\n\n    /**\n     * 返回此列表中的元素数。\n     */\n    public int size() {\n        return size;\n    }\n\n    /**\n     * 如果此列表不包含元素，则返回 true 。\n     */\n    public boolean isEmpty() {\n        //注意=和==的区别\n        return size == 0;\n    }\n\n    /**\n     * 如果此列表包含指定的元素，则返回true 。\n     */\n    public boolean contains(Object o) {\n        //indexOf()方法：返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1\n        return indexOf(o) >= 0;\n    }\n\n    /**\n     * 返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1\n     */\n    public int indexOf(Object o) {\n        if (o == null) {\n            for (int i = 0; i < size; i++)\n                if (elementData[i] == null)\n                    return i;\n        } else {\n            for (int i = 0; i < size; i++)\n                //equals()方法比较\n                if (o.equals(elementData[i]))\n                    return i;\n        }\n        return -1;\n    }\n\n    /**\n     * 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。.\n     */\n    public int lastIndexOf(Object o) {\n        if (o == null) {\n            for (int i = size - 1; i >= 0; i--)\n                if (elementData[i] == null)\n                    return i;\n        } else {\n            for (int i = size - 1; i >= 0; i--)\n                if (o.equals(elementData[i]))\n                    return i;\n        }\n        return -1;\n    }\n\n    /**\n     * 返回此ArrayList实例的浅拷贝。 （元素本身不被复制。）\n     */\n    public Object clone() {\n        try {\n            ArrayList<?> v = (ArrayList<?>) super.clone();\n            //Arrays.copyOf功能是实现数组的复制，返回复制后的数组。参数是被复制的数组和复制的长度\n            v.elementData = Arrays.copyOf(elementData, size);\n            v.modCount = 0;\n            return v;\n        } catch (CloneNotSupportedException e) {\n            // 这不应该发生，因为我们是可以克隆的\n            throw new InternalError(e);\n        }\n    }\n\n    /**\n     * 以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。\n     * 返回的数组将是“安全的”，因为该列表不保留对它的引用。\n     * （换句话说，这个方法必须分配一个新的数组）。\n     * 因此，调用者可以自由地修改返回的数组结构。\n     * 注意：如果元素是引用类型，修改元素的内容会影响到原列表中的对象。\n     * 此方法充当基于数组和基于集合的API之间的桥梁。\n     */\n    public Object[] toArray() {\n        return Arrays.copyOf(elementData, size);\n    }\n\n    /**\n     * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）;\n     * 返回的数组的运行时类型是指定数组的运行时类型。 如果列表适合指定的数组，则返回其中。\n     * 否则，将为指定数组的运行时类型和此列表的大小分配一个新数组。\n     * 如果列表适用于指定的数组，其余空间（即数组的列表数量多于此元素），则紧跟在集合结束后的数组中的元素设置为null 。\n     * （这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度。）\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T[] toArray(T[] a) {\n        if (a.length < size)\n            // 新建一个运行时类型的数组，但是ArrayList数组的内容\n            return (T[]) Arrays.copyOf(elementData, size, a.getClass());\n        //调用System提供的arraycopy()方法实现数组之间的复制\n        System.arraycopy(elementData, 0, a, 0, size);\n        if (a.length > size)\n            a[size] = null;\n        return a;\n    }\n\n    // Positional Access Operations\n\n    @SuppressWarnings(\"unchecked\")\n    E elementData(int index) {\n        return (E) elementData[index];\n    }\n\n    /**\n     * 返回此列表中指定位置的元素。\n     */\n    public E get(int index) {\n        rangeCheck(index);\n\n        return elementData(index);\n    }\n\n    /**\n     * 用指定的元素替换此列表中指定位置的元素。\n     */\n    public E set(int index, E element) {\n        //对index进行界限检查\n        rangeCheck(index);\n\n        E oldValue = elementData(index);\n        elementData[index] = element;\n        //返回原来在这个位置的元素\n        return oldValue;\n    }\n\n    /**\n     * 将指定的元素追加到此列表的末尾。\n     */\n    public boolean add(E e) {\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        //这里看到ArrayList添加元素的实质就相当于为数组赋值\n        elementData[size++] = e;\n        return true;\n    }\n\n    /**\n     * 在此列表中的指定位置插入指定的元素。\n     * 先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；\n     * 再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。\n     */\n    public void add(int index, E element) {\n        rangeCheckForAdd(index);\n\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        //arraycopy()这个实现数组之间复制的方法一定要看一下，下面就用到了arraycopy()方法实现数组自己复制自己\n        System.arraycopy(elementData, index, elementData, index + 1,\n                size - index);\n        elementData[index] = element;\n        size++;\n    }\n\n    /**\n     * 删除该列表中指定位置的元素。 将任何后续元素移动到左侧（从其索引中减去一个元素）。\n     */\n    public E remove(int index) {\n        rangeCheck(index);\n\n        modCount++;\n        E oldValue = elementData(index);\n\n        int numMoved = size - index - 1;\n        if (numMoved > 0)\n            System.arraycopy(elementData, index + 1, elementData, index,\n                    numMoved);\n        elementData[--size] = null; // clear to let GC do its work\n        //从列表中删除的元素\n        return oldValue;\n    }\n\n    /**\n     * 从列表中删除指定元素的第一个出现（如果存在）。 如果列表不包含该元素，则它不会更改。\n     * 返回true，如果此列表包含指定的元素\n     */\n    public boolean remove(Object o) {\n        if (o == null) {\n            for (int index = 0; index < size; index++)\n                if (elementData[index] == null) {\n                    fastRemove(index);\n                    return true;\n                }\n        } else {\n            for (int index = 0; index < size; index++)\n                if (o.equals(elementData[index])) {\n                    fastRemove(index);\n                    return true;\n                }\n        }\n        return false;\n    }\n\n    /*\n     * 该方法为私有的移除方法，跳过了边界检查，并且不返回被移除的值。\n     */\n    private void fastRemove(int index) {\n        modCount++;\n        int numMoved = size - index - 1;\n        if (numMoved > 0)\n            System.arraycopy(elementData, index + 1, elementData, index,\n                    numMoved);\n        elementData[--size] = null; // 在移除元素后，将该位置的元素设为 null，以便垃圾回收器（GC）能够回收该元素。\n    }\n\n    /**\n     * 从列表中删除所有元素。\n     */\n    public void clear() {\n        modCount++;\n\n        // 把数组中所有的元素的值设为null\n        for (int i = 0; i < size; i++)\n            elementData[i] = null;\n\n        size = 0;\n    }\n\n    /**\n     * 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。\n     */\n    public boolean addAll(Collection<? extends E> c) {\n        Object[] a = c.toArray();\n        int numNew = a.length;\n        ensureCapacityInternal(size + numNew);  // Increments modCount\n        System.arraycopy(a, 0, elementData, size, numNew);\n        size += numNew;\n        return numNew != 0;\n    }\n\n    /**\n     * 将指定集合中的所有元素插入到此列表中，从指定的位置开始。\n     */\n    public boolean addAll(int index, Collection<? extends E> c) {\n        rangeCheckForAdd(index);\n\n        Object[] a = c.toArray();\n        int numNew = a.length;\n        ensureCapacityInternal(size + numNew);  // Increments modCount\n\n        int numMoved = size - index;\n        if (numMoved > 0)\n            System.arraycopy(elementData, index, elementData, index + numNew,\n                    numMoved);\n\n        System.arraycopy(a, 0, elementData, index, numNew);\n        size += numNew;\n        return numNew != 0;\n    }\n\n    /**\n     * 从此列表中删除所有索引为fromIndex （含）和toIndex之间的元素。\n     * 将任何后续元素移动到左侧（减少其索引）。\n     */\n    protected void removeRange(int fromIndex, int toIndex) {\n        modCount++;\n        int numMoved = size - toIndex;\n        System.arraycopy(elementData, toIndex, elementData, fromIndex,\n                numMoved);\n\n        // clear to let GC do its work\n        int newSize = size - (toIndex - fromIndex);\n        for (int i = newSize; i < size; i++) {\n            elementData[i] = null;\n        }\n        size = newSize;\n    }\n\n    /**\n     * 检查给定的索引是否在范围内。\n     */\n    private void rangeCheck(int index) {\n        if (index >= size)\n            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n    }\n\n    /**\n     * add和addAll使用的rangeCheck的一个版本\n     */\n    private void rangeCheckForAdd(int index) {\n        if (index > size || index < 0)\n            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n    }\n\n    /**\n     * 返回IndexOutOfBoundsException细节信息\n     */\n    private String outOfBoundsMsg(int index) {\n        return \"Index: \" + index + \", Size: \" + size;\n    }\n\n    /**\n     * 从此列表中删除指定集合中包含的所有元素。\n     */\n    public boolean removeAll(Collection<?> c) {\n        Objects.requireNonNull(c);\n        //如果此列表被修改则返回true\n        return batchRemove(c, false);\n    }\n\n    /**\n     * 仅保留此列表中包含在指定集合中的元素。\n     * 换句话说，从此列表中删除其中不包含在指定集合中的所有元素。\n     */\n    public boolean retainAll(Collection<?> c) {\n        Objects.requireNonNull(c);\n        return batchRemove(c, true);\n    }\n\n\n    /**\n     * 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。\n     * 指定的索引表示初始调用将返回的第一个元素为next 。 初始调用previous将返回指定索引减1的元素。\n     * 返回的列表迭代器是fail-fast 。\n     */\n    public ListIterator<E> listIterator(int index) {\n        if (index < 0 || index > size)\n            throw new IndexOutOfBoundsException(\"Index: \" + index);\n        return new ListItr(index);\n    }\n\n    /**\n     * 返回列表中的列表迭代器（按适当的顺序）。\n     * 返回的列表迭代器是fail-fast 。\n     */\n    public ListIterator<E> listIterator() {\n        return new ListItr(0);\n    }\n\n    /**\n     * 以正确的顺序返回该列表中的元素的迭代器。\n     * 返回的迭代器是fail-fast 。\n     */\n    public Iterator<E> iterator() {\n        return new Itr();\n    }\n```\n\n## ArrayList 扩容机制分析\n\n### 先从 ArrayList 的构造函数说起\n\nArrayList 有三种方式来初始化，构造方法源码如下（JDK8）：\n\n```java\n/**\n * 默认初始容量大小\n */\nprivate static final int DEFAULT_CAPACITY = 10;\n\nprivate static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n\n/**\n * 默认构造函数，使用初始容量10构造一个空列表(无参数构造)\n */\npublic ArrayList() {\n    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n}\n\n/**\n * 带初始容量参数的构造函数。（用户自己指定容量）\n */\npublic ArrayList(int initialCapacity) {\n    if (initialCapacity > 0) {//初始容量大于0\n        //创建initialCapacity大小的数组\n        this.elementData = new Object[initialCapacity];\n    } else if (initialCapacity == 0) {//初始容量等于0\n        //创建空数组\n        this.elementData = EMPTY_ELEMENTDATA;\n    } else {//初始容量小于0，抛出异常\n        throw new IllegalArgumentException(\"Illegal Capacity: \" + initialCapacity);\n    }\n}\n\n\n/**\n *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回\n *如果指定的集合为null，throws NullPointerException。\n */\npublic ArrayList(Collection<? extends E> c) {\n    elementData = c.toArray();\n    if ((size = elementData.length) != 0) {\n        // c.toArray might (incorrectly) not return Object[] (see 6260652)\n        if (elementData.getClass() != Object[].class)\n            elementData = Arrays.copyOf(elementData, size, Object[].class);\n    } else {\n        // replace with empty array.\n        this.elementData = EMPTY_ELEMENTDATA;\n    }\n}\n```\n\n细心的同学一定会发现：**以无参数构造方法创建 `ArrayList` 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。** 下面在我们分析 `ArrayList` 扩容时会讲到这一点内容！\n\n> 补充：JDK6 new 无参构造的 `ArrayList` 对象时，直接创建了长度是 10 的 `Object[]` 数组 `elementData` 。\n\n### 一步一步分析 ArrayList 扩容机制\n\n这里以无参构造函数创建的 `ArrayList` 为例分析。\n\n#### add 方法\n\n```java\n/**\n* 将指定的元素追加到此列表的末尾。\n*/\npublic boolean add(E e) {\n    // 加元素之前，先调用ensureCapacityInternal方法\n    ensureCapacityInternal(size + 1);  // Increments modCount!!\n    // 这里看到ArrayList添加元素的实质就相当于为数组赋值\n    elementData[size++] = e;\n    return true;\n}\n```\n\n**注意**：JDK11 移除了 `ensureCapacityInternal()` 和 `ensureExplicitCapacity()` 方法\n\n`ensureCapacityInternal` 方法的源码如下：\n\n```java\n// 根据给定的最小容量和当前数组元素来计算所需容量。\nprivate static int calculateCapacity(Object[] elementData, int minCapacity) {\n    // 如果当前数组元素为空数组（初始情况），返回默认容量和最小容量中的较大值作为所需容量\n    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n        return Math.max(DEFAULT_CAPACITY, minCapacity);\n    }\n    // 否则直接返回最小容量\n    return minCapacity;\n}\n\n// 确保内部容量达到指定的最小容量。\nprivate void ensureCapacityInternal(int minCapacity) {\n    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));\n}\n```\n\n`ensureCapacityInternal` 方法非常简单，内部直接调用了 `ensureExplicitCapacity` 方法：\n\n```java\n//判断是否需要扩容\nprivate void ensureExplicitCapacity(int minCapacity) {\n    modCount++;\n    //判断当前数组容量是否足以存储minCapacity个元素\n    if (minCapacity - elementData.length > 0)\n        //调用grow方法进行扩容\n        grow(minCapacity);\n}\n```\n\n我们来仔细分析一下：\n\n- 当我们要 `add` 进第 1 个元素到 `ArrayList` 时，`elementData.length` 为 0 （因为还是一个空的 list），因为执行了 `ensureCapacityInternal()` 方法 ，所以 `minCapacity` 此时为 10。此时，`minCapacity - elementData.length > 0`成立，所以会进入 `grow(minCapacity)` 方法。\n- 当 `add` 第 2 个元素时，`minCapacity` 为 2，此时 `elementData.length`(容量)在添加第一个元素后扩容成 `10` 了。此时，`minCapacity - elementData.length > 0` 不成立，所以不会进入 （执行）`grow(minCapacity)` 方法。\n- 添加第 3、4···到第 10 个元素时，依然不会执行 grow 方法，数组容量都为 10。\n\n直到添加第 11 个元素，`minCapacity`(为 11)比 `elementData.length`（为 10）要大。进入 `grow` 方法进行扩容。\n\n#### grow 方法\n\n```java\n/**\n * 要分配的最大数组大小\n */\nprivate static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n\n/**\n * ArrayList扩容的核心方法。\n */\nprivate void grow(int minCapacity) {\n    // oldCapacity为旧容量，newCapacity为新容量\n    int oldCapacity = elementData.length;\n    // 将oldCapacity 右移一位，其效果相当于oldCapacity /2，\n    // 我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，\n    int newCapacity = oldCapacity + (oldCapacity >> 1);\n\n    // 然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，\n    if (newCapacity - minCapacity < 0)\n        newCapacity = minCapacity;\n\n    // 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，\n    // 如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。\n    if (newCapacity - MAX_ARRAY_SIZE > 0)\n        newCapacity = hugeCapacity(minCapacity);\n\n    // minCapacity is usually close to size, so this is a win:\n    elementData = Arrays.copyOf(elementData, newCapacity);\n}\n```\n\n**`int newCapacity = oldCapacity + (oldCapacity >> 1)`,所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！** 奇偶不同，比如：10+10/2 = 15, 33+33/2=49。如果是奇数的话会丢掉小数.\n\n> \">>\"（移位运算符）：>>1 右移一位相当于除 2，右移 n 位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了 1 位所以相当于 oldCapacity /2。对于大数据的 2 进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已,不去计算,这样提高了效率,节省了资源\n\n**我们再来通过例子探究一下`grow()` 方法：**\n\n- 当 `add` 第 1 个元素时，`oldCapacity` 为 0，经比较后第一个 if 判断成立，`newCapacity = minCapacity`(为 10)。但是第二个 if 判断不会成立，即 `newCapacity` 不比 `MAX_ARRAY_SIZE` 大，则不会进入 `hugeCapacity` 方法。数组容量为 10，`add` 方法中 return true,size 增为 1。\n- 当 `add` 第 11 个元素进入 `grow` 方法时，`newCapacity` 为 15，比 `minCapacity`（为 11）大，第一个 if 判断不成立。新容量没有大于数组最大 size，不会进入 `hugeCapacity` 方法。数组容量扩为 15，add 方法中 return true,size 增为 11。\n- 以此类推······\n\n**这里补充一点比较重要，但是容易被忽视掉的知识点：**\n\n- Java 中的 `length`属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.\n- Java 中的 `length()` 方法是针对字符串说的,如果想看这个字符串的长度则用到 `length()` 这个方法.\n- Java 中的 `size()` 方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!\n\n#### hugeCapacity() 方法\n\n从上面 `grow()` 方法源码我们知道：如果新容量大于 `MAX_ARRAY_SIZE`,进入(执行) `hugeCapacity()` 方法来比较 `minCapacity` 和 `MAX_ARRAY_SIZE`，如果 `minCapacity` 大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 `MAX_ARRAY_SIZE` 即为 `Integer.MAX_VALUE - 8`。\n\n```java\nprivate static int hugeCapacity(int minCapacity) {\n    if (minCapacity < 0) // overflow\n        throw new OutOfMemoryError();\n    // 对minCapacity和MAX_ARRAY_SIZE进行比较\n    // 若minCapacity大，将Integer.MAX_VALUE作为新数组的大小\n    // 若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小\n    // MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n    return (minCapacity > MAX_ARRAY_SIZE) ?\n        Integer.MAX_VALUE :\n        MAX_ARRAY_SIZE;\n}\n```\n\n### `System.arraycopy()` 和 `Arrays.copyOf()`方法\n\n阅读源码的话，我们就会发现 `ArrayList` 中大量调用了这两个方法。比如：我们上面讲的扩容操作以及`add(int index, E element)`、`toArray()` 等方法中都用到了该方法！\n\n#### `System.arraycopy()` 方法\n\n源码：\n\n```java\n    // 我们发现 arraycopy 是一个 native 方法,接下来我们解释一下各个参数的具体意义\n    /**\n    *   复制数组\n    * @param src 源数组\n    * @param srcPos 源数组中的起始位置\n    * @param dest 目标数组\n    * @param destPos 目标数组中的起始位置\n    * @param length 要复制的数组元素的数量\n    */\n    public static native void arraycopy(Object src,  int  srcPos,\n                                        Object dest, int destPos,\n                                        int length);\n```\n\n场景：\n\n```java\n    /**\n     * 在此列表中的指定位置插入指定的元素。\n     *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；\n     *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。\n     */\n    public void add(int index, E element) {\n        rangeCheckForAdd(index);\n\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        //arraycopy()方法实现数组自己复制自己\n        //elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；\n        System.arraycopy(elementData, index, elementData, index + 1, size - index);\n        elementData[index] = element;\n        size++;\n    }\n```\n\n我们写一个简单的方法测试以下：\n\n```java\npublic class ArraycopyTest {\n\n  public static void main(String[] args) {\n    // TODO Auto-generated method stub\n    int[] a = new int[10];\n    a[0] = 0;\n    a[1] = 1;\n    a[2] = 2;\n    a[3] = 3;\n    System.arraycopy(a, 2, a, 3, 3);\n    a[2]=99;\n    for (int i = 0; i < a.length; i++) {\n      System.out.print(a[i] + \" \");\n    }\n  }\n\n}\n```\n\n结果：\n\n```plain\n0 1 99 2 3 0 0 0 0 0\n```\n\n#### `Arrays.copyOf()`方法\n\n源码：\n\n```java\n    public static int[] copyOf(int[] original, int newLength) {\n      // 申请一个新的数组\n        int[] copy = new int[newLength];\n  // 调用System.arraycopy,将源数组中的数据进行拷贝,并返回新的数组\n        System.arraycopy(original, 0, copy, 0,\n                         Math.min(original.length, newLength));\n        return copy;\n    }\n```\n\n场景：\n\n```java\n   /**\n     以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型。\n     */\n    public Object[] toArray() {\n    //elementData：要复制的数组；size：要复制的长度\n        return Arrays.copyOf(elementData, size);\n    }\n```\n\n个人觉得使用 `Arrays.copyOf()`方法主要是为了给原有数组扩容，测试代码如下：\n\n```java\npublic class ArrayscopyOfTest {\n\n  public static void main(String[] args) {\n    int[] a = new int[3];\n    a[0] = 0;\n    a[1] = 1;\n    a[2] = 2;\n    int[] b = Arrays.copyOf(a, 10);\n    System.out.println(\"b.length\"+b.length);\n  }\n}\n```\n\n结果：\n\n```plain\n10\n```\n\n#### 两者联系和区别\n\n**联系：**\n\n看两者源代码可以发现 `copyOf()`内部实际调用了 `System.arraycopy()` 方法\n\n**区别：**\n\n`arraycopy()` 需要目标数组，将原数组拷贝到你自己定义的数组里或者原数组，而且可以选择拷贝的起点和长度以及放入新数组中的位置 `copyOf()` 是系统自动在内部新建一个数组，并返回该数组。\n\n### `ensureCapacity`方法\n\n`ArrayList` 源码中有一个 `ensureCapacity` 方法不知道大家注意到没有，这个方法 `ArrayList` 内部没有被调用过，所以很显然是提供给用户调用的，那么这个方法有什么作用呢？\n\n```java\n    /**\n    如有必要，增加此 ArrayList 实例的容量，以确保它至少可以容纳由minimum capacity参数指定的元素数。\n     *\n     * @param   minCapacity   所需的最小容量\n     */\n    public void ensureCapacity(int minCapacity) {\n        int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)\n            // any size if not default element table\n            ? 0\n            // larger than default for default empty table. It's already\n            // supposed to be at default size.\n            : DEFAULT_CAPACITY;\n\n        if (minCapacity > minExpand) {\n            ensureExplicitCapacity(minCapacity);\n        }\n    }\n\n```\n\n理论上来说，最好在向 `ArrayList` 添加大量元素之前用 `ensureCapacity` 方法，以减少增量重新分配的次数\n\n我们通过下面的代码实际测试以下这个方法的效果：\n\n```java\npublic class EnsureCapacityTest {\n  public static void main(String[] args) {\n    ArrayList<Object> list = new ArrayList<Object>();\n    final int N = 10000000;\n    long startTime = System.currentTimeMillis();\n    for (int i = 0; i < N; i++) {\n      list.add(i);\n    }\n    long endTime = System.currentTimeMillis();\n    System.out.println(\"使用ensureCapacity方法前：\"+(endTime - startTime));\n\n  }\n}\n```\n\n运行结果：\n\n```plain\n使用ensureCapacity方法前：2158\n```\n\n```java\npublic class EnsureCapacityTest {\n    public static void main(String[] args) {\n        ArrayList<Object> list = new ArrayList<Object>();\n        final int N = 10000000;\n        long startTime1 = System.currentTimeMillis();\n        list.ensureCapacity(N);\n        for (int i = 0; i < N; i++) {\n            list.add(i);\n        }\n        long endTime1 = System.currentTimeMillis();\n        System.out.println(\"使用ensureCapacity方法后：\"+(endTime1 - startTime1));\n    }\n}\n```\n\n运行结果：\n\n```plain\n使用ensureCapacity方法后：1773\n```\n\n通过运行结果，我们可以看出向 `ArrayList` 添加大量元素之前使用`ensureCapacity` 方法可以提升性能。不过，这个性能差距几乎可以忽略不计。而且，实际项目根本也不可能往 `ArrayList` 里面添加这么多元素。","source":"_posts/Java/collection/arraylist-source-code.md","raw":"---\ntitle: ArrayList 源码分析\ncategories: [ Java, collection ]\ndate: 2025-12-27 17:07:20\ntags: [ Java, collection ]\npermalink: /Java/collection/\n---\n\n## ArrayList 简介\n\n`ArrayList` 的底层是数组队列，相当于动态数组。与 Java 中的数组相比，它的容量能动态增长。在添加大量元素前，应用程序可以使用`ensureCapacity`操作来增加 `ArrayList` 实例的容量。这可以减少递增式再分配的数量。\n\n`ArrayList` 继承于 `AbstractList` ，实现了 `List`, `RandomAccess`, `Cloneable`, `java.io.Serializable` 这些接口。\n\n```java\n\npublic class ArrayList<E> extends AbstractList<E>\n        implements List<E>, RandomAccess, Cloneable, java.io.Serializable{\n\n  }\n```\n\n- `List` : 表明它是一个列表，支持添加、删除、查找等操作，并且可以通过下标进行访问。\n- `RandomAccess` ：这是一个标志接口，表明实现这个接口的 `List` 集合是支持 **快速随机访问** 的。在 `ArrayList` 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。\n- `Cloneable` ：表明它具有拷贝能力，可以进行深拷贝或浅拷贝操作。\n- `Serializable` : 表明它可以进行序列化操作，也就是可以将对象转换为字节流进行持久化存储或网络传输，非常方便。\n\n\n### ArrayList 和 Vector 的区别?（了解即可）\n\n- `ArrayList` 是 `List` 的主要实现类，底层使用 `Object[]`存储，适用于频繁的查找工作，线程不安全 。\n- `Vector` 是 `List` 的古老实现类，底层使用`Object[]` 存储，线程安全。\n\n### ArrayList 可以添加 null 值吗？\n\n`ArrayList` 中可以存储任何类型的对象，包括 `null` 值。不过，不建议向`ArrayList` 中添加 `null` 值， `null` 值无意义，会让代码难以维护比如忘记做判空处理就会导致空指针异常。\n\n示例代码：\n\n```java\nArrayList<String> listOfStrings = new ArrayList<>();\nlistOfStrings.add(null);\nlistOfStrings.add(\"java\");\nSystem.out.println(listOfStrings);\n```\n\n输出：\n\n```plain\n[null, java]\n```\n\n### Arraylist 与 LinkedList 区别?\n\n- **是否保证线程安全：** `ArrayList` 和 `LinkedList` 都是不同步的，也就是不保证线程安全；\n- **底层数据结构：** `ArrayList` 底层使用的是 **`Object` 数组**；`LinkedList` 底层使用的是 **双向链表** 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）\n- **插入和删除是否受元素位置的影响：**\n    - `ArrayList` 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行`add(E e)`方法的时候， `ArrayList` 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（`add(int index, E element)`），时间复杂度就为 O(n)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。\n    - `LinkedList` 采用链表存储，所以在头尾插入或者删除元素不受元素位置的影响（`add(E e)`、`addFirst(E e)`、`addLast(E e)`、`removeFirst()`、 `removeLast()`），时间复杂度为 O(1)，如果是要在指定位置 `i` 插入和删除元素的话（`add(int index, E element)`，`remove(Object o)`,`remove(int index)`）， 时间复杂度为 O(n) ，因为需要先移动到指定位置再插入和删除。\n- **是否支持快速随机访问：** `LinkedList` 不支持高效的随机元素访问，而 `ArrayList`（实现了 `RandomAccess` 接口） 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于`get(int index)`方法)。\n- **内存空间占用：** `ArrayList` 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。\n\n## ArrayList 核心源码解读\n\n这里以 JDK1.8 为例，分析一下 `ArrayList` 的底层源码。\n\n```java\npublic class ArrayList<E> extends AbstractList<E>\n        implements List<E>, RandomAccess, Cloneable, java.io.Serializable {\n    private static final long serialVersionUID = 8683452581122892189L;\n\n    /**\n     * 默认初始容量大小\n     */\n    private static final int DEFAULT_CAPACITY = 10;\n\n    /**\n     * 空数组（用于空实例）。\n     */\n    private static final Object[] EMPTY_ELEMENTDATA = {};\n\n    //用于默认大小空实例的共享空数组实例。\n    //我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。\n    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n\n    /**\n     * 保存ArrayList数据的数组\n     */\n    transient Object[] elementData; // non-private to simplify nested class access\n\n    /**\n     * ArrayList 所包含的元素个数\n     */\n    private int size;\n\n    /**\n     * 带初始容量参数的构造函数（用户可以在创建ArrayList对象时自己指定集合的初始大小）\n     */\n    public ArrayList(int initialCapacity) {\n        if (initialCapacity > 0) {\n            //如果传入的参数大于0，创建initialCapacity大小的数组\n            this.elementData = new Object[initialCapacity];\n        } else if (initialCapacity == 0) {\n            //如果传入的参数等于0，创建空数组\n            this.elementData = EMPTY_ELEMENTDATA;\n        } else {\n            //其他情况，抛出异常\n            throw new IllegalArgumentException(\"Illegal Capacity: \" +\n                    initialCapacity);\n        }\n    }\n\n    /**\n     * 默认无参构造函数\n     * DEFAULTCAPACITY_EMPTY_ELEMENTDATA 为0.初始化为10，也就是说初始其实是空数组 当添加第一个元素的时候数组容量才变成10\n     */\n    public ArrayList() {\n        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n    }\n\n    /**\n     * 构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。\n     */\n    public ArrayList(Collection<? extends E> c) {\n        //将指定集合转换为数组\n        elementData = c.toArray();\n        //如果elementData数组的长度不为0\n        if ((size = elementData.length) != 0) {\n            // 如果elementData不是Object类型数据（c.toArray可能返回的不是Object类型的数组所以加上下面的语句用于判断）\n            if (elementData.getClass() != Object[].class)\n                //将原来不是Object类型的elementData数组的内容，赋值给新的Object类型的elementData数组\n                elementData = Arrays.copyOf(elementData, size, Object[].class);\n        } else {\n            // 其他情况，用空数组代替\n            this.elementData = EMPTY_ELEMENTDATA;\n        }\n    }\n\n    /**\n     * 修改这个ArrayList实例的容量是列表的当前大小。 应用程序可以使用此操作来最小化ArrayList实例的存储。\n     */\n    public void trimToSize() {\n        modCount++;\n        if (size < elementData.length) {\n            elementData = (size == 0)\n                    ? EMPTY_ELEMENTDATA\n                    : Arrays.copyOf(elementData, size);\n        }\n    }\n//下面是ArrayList的扩容机制\n//ArrayList的扩容机制提高了性能，如果每次只扩充一个，\n//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。\n\n    /**\n     * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量\n     *\n     * @param minCapacity 所需的最小容量\n     */\n    public void ensureCapacity(int minCapacity) {\n        // 如果不是默认空数组，则minExpand的值为0；\n        // 如果是默认空数组，则minExpand的值为10\n        int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)\n                // 如果不是默认元素表，则可以使用任意大小\n                ? 0\n                // 如果是默认空数组，它应该已经是默认大小\n                : DEFAULT_CAPACITY;\n\n        // 如果最小容量大于已有的最大容量\n        if (minCapacity > minExpand) {\n            // 根据需要的最小容量，确保容量足够\n            ensureExplicitCapacity(minCapacity);\n        }\n    }\n\n\n    // 根据给定的最小容量和当前数组元素来计算所需容量。\n    private static int calculateCapacity(Object[] elementData, int minCapacity) {\n        // 如果当前数组元素为空数组（初始情况），返回默认容量和最小容量中的较大值作为所需容量\n        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n            return Math.max(DEFAULT_CAPACITY, minCapacity);\n        }\n        // 否则直接返回最小容量\n        return minCapacity;\n    }\n\n    // 确保内部容量达到指定的最小容量。\n    private void ensureCapacityInternal(int minCapacity) {\n        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));\n    }\n\n    //判断是否需要扩容\n    private void ensureExplicitCapacity(int minCapacity) {\n        modCount++;\n        // overflow-conscious code\n        if (minCapacity - elementData.length > 0)\n            //调用grow方法进行扩容，调用此方法代表已经开始扩容了\n            grow(minCapacity);\n    }\n\n    /**\n     * 要分配的最大数组大小\n     */\n    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n\n    /**\n     * ArrayList扩容的核心方法。\n     */\n    private void grow(int minCapacity) {\n        // oldCapacity为旧容量，newCapacity为新容量\n        int oldCapacity = elementData.length;\n        //将oldCapacity 右移一位，其效果相当于oldCapacity /2，\n        //我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，\n        int newCapacity = oldCapacity + (oldCapacity >> 1);\n        //然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，\n        if (newCapacity - minCapacity < 0)\n            newCapacity = minCapacity;\n        //再检查新容量是否超出了ArrayList所定义的最大容量，\n        //若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，\n        //如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Integer.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。\n        if (newCapacity - MAX_ARRAY_SIZE > 0)\n            newCapacity = hugeCapacity(minCapacity);\n        // minCapacity is usually close to size, so this is a win:\n        elementData = Arrays.copyOf(elementData, newCapacity);\n    }\n\n    //比较minCapacity和 MAX_ARRAY_SIZE\n    private static int hugeCapacity(int minCapacity) {\n        if (minCapacity < 0) // overflow\n            throw new OutOfMemoryError();\n        return (minCapacity > MAX_ARRAY_SIZE) ?\n                Integer.MAX_VALUE :\n                MAX_ARRAY_SIZE;\n    }\n\n    /**\n     * 返回此列表中的元素数。\n     */\n    public int size() {\n        return size;\n    }\n\n    /**\n     * 如果此列表不包含元素，则返回 true 。\n     */\n    public boolean isEmpty() {\n        //注意=和==的区别\n        return size == 0;\n    }\n\n    /**\n     * 如果此列表包含指定的元素，则返回true 。\n     */\n    public boolean contains(Object o) {\n        //indexOf()方法：返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1\n        return indexOf(o) >= 0;\n    }\n\n    /**\n     * 返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1\n     */\n    public int indexOf(Object o) {\n        if (o == null) {\n            for (int i = 0; i < size; i++)\n                if (elementData[i] == null)\n                    return i;\n        } else {\n            for (int i = 0; i < size; i++)\n                //equals()方法比较\n                if (o.equals(elementData[i]))\n                    return i;\n        }\n        return -1;\n    }\n\n    /**\n     * 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。.\n     */\n    public int lastIndexOf(Object o) {\n        if (o == null) {\n            for (int i = size - 1; i >= 0; i--)\n                if (elementData[i] == null)\n                    return i;\n        } else {\n            for (int i = size - 1; i >= 0; i--)\n                if (o.equals(elementData[i]))\n                    return i;\n        }\n        return -1;\n    }\n\n    /**\n     * 返回此ArrayList实例的浅拷贝。 （元素本身不被复制。）\n     */\n    public Object clone() {\n        try {\n            ArrayList<?> v = (ArrayList<?>) super.clone();\n            //Arrays.copyOf功能是实现数组的复制，返回复制后的数组。参数是被复制的数组和复制的长度\n            v.elementData = Arrays.copyOf(elementData, size);\n            v.modCount = 0;\n            return v;\n        } catch (CloneNotSupportedException e) {\n            // 这不应该发生，因为我们是可以克隆的\n            throw new InternalError(e);\n        }\n    }\n\n    /**\n     * 以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。\n     * 返回的数组将是“安全的”，因为该列表不保留对它的引用。\n     * （换句话说，这个方法必须分配一个新的数组）。\n     * 因此，调用者可以自由地修改返回的数组结构。\n     * 注意：如果元素是引用类型，修改元素的内容会影响到原列表中的对象。\n     * 此方法充当基于数组和基于集合的API之间的桥梁。\n     */\n    public Object[] toArray() {\n        return Arrays.copyOf(elementData, size);\n    }\n\n    /**\n     * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）;\n     * 返回的数组的运行时类型是指定数组的运行时类型。 如果列表适合指定的数组，则返回其中。\n     * 否则，将为指定数组的运行时类型和此列表的大小分配一个新数组。\n     * 如果列表适用于指定的数组，其余空间（即数组的列表数量多于此元素），则紧跟在集合结束后的数组中的元素设置为null 。\n     * （这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度。）\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T[] toArray(T[] a) {\n        if (a.length < size)\n            // 新建一个运行时类型的数组，但是ArrayList数组的内容\n            return (T[]) Arrays.copyOf(elementData, size, a.getClass());\n        //调用System提供的arraycopy()方法实现数组之间的复制\n        System.arraycopy(elementData, 0, a, 0, size);\n        if (a.length > size)\n            a[size] = null;\n        return a;\n    }\n\n    // Positional Access Operations\n\n    @SuppressWarnings(\"unchecked\")\n    E elementData(int index) {\n        return (E) elementData[index];\n    }\n\n    /**\n     * 返回此列表中指定位置的元素。\n     */\n    public E get(int index) {\n        rangeCheck(index);\n\n        return elementData(index);\n    }\n\n    /**\n     * 用指定的元素替换此列表中指定位置的元素。\n     */\n    public E set(int index, E element) {\n        //对index进行界限检查\n        rangeCheck(index);\n\n        E oldValue = elementData(index);\n        elementData[index] = element;\n        //返回原来在这个位置的元素\n        return oldValue;\n    }\n\n    /**\n     * 将指定的元素追加到此列表的末尾。\n     */\n    public boolean add(E e) {\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        //这里看到ArrayList添加元素的实质就相当于为数组赋值\n        elementData[size++] = e;\n        return true;\n    }\n\n    /**\n     * 在此列表中的指定位置插入指定的元素。\n     * 先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；\n     * 再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。\n     */\n    public void add(int index, E element) {\n        rangeCheckForAdd(index);\n\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        //arraycopy()这个实现数组之间复制的方法一定要看一下，下面就用到了arraycopy()方法实现数组自己复制自己\n        System.arraycopy(elementData, index, elementData, index + 1,\n                size - index);\n        elementData[index] = element;\n        size++;\n    }\n\n    /**\n     * 删除该列表中指定位置的元素。 将任何后续元素移动到左侧（从其索引中减去一个元素）。\n     */\n    public E remove(int index) {\n        rangeCheck(index);\n\n        modCount++;\n        E oldValue = elementData(index);\n\n        int numMoved = size - index - 1;\n        if (numMoved > 0)\n            System.arraycopy(elementData, index + 1, elementData, index,\n                    numMoved);\n        elementData[--size] = null; // clear to let GC do its work\n        //从列表中删除的元素\n        return oldValue;\n    }\n\n    /**\n     * 从列表中删除指定元素的第一个出现（如果存在）。 如果列表不包含该元素，则它不会更改。\n     * 返回true，如果此列表包含指定的元素\n     */\n    public boolean remove(Object o) {\n        if (o == null) {\n            for (int index = 0; index < size; index++)\n                if (elementData[index] == null) {\n                    fastRemove(index);\n                    return true;\n                }\n        } else {\n            for (int index = 0; index < size; index++)\n                if (o.equals(elementData[index])) {\n                    fastRemove(index);\n                    return true;\n                }\n        }\n        return false;\n    }\n\n    /*\n     * 该方法为私有的移除方法，跳过了边界检查，并且不返回被移除的值。\n     */\n    private void fastRemove(int index) {\n        modCount++;\n        int numMoved = size - index - 1;\n        if (numMoved > 0)\n            System.arraycopy(elementData, index + 1, elementData, index,\n                    numMoved);\n        elementData[--size] = null; // 在移除元素后，将该位置的元素设为 null，以便垃圾回收器（GC）能够回收该元素。\n    }\n\n    /**\n     * 从列表中删除所有元素。\n     */\n    public void clear() {\n        modCount++;\n\n        // 把数组中所有的元素的值设为null\n        for (int i = 0; i < size; i++)\n            elementData[i] = null;\n\n        size = 0;\n    }\n\n    /**\n     * 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。\n     */\n    public boolean addAll(Collection<? extends E> c) {\n        Object[] a = c.toArray();\n        int numNew = a.length;\n        ensureCapacityInternal(size + numNew);  // Increments modCount\n        System.arraycopy(a, 0, elementData, size, numNew);\n        size += numNew;\n        return numNew != 0;\n    }\n\n    /**\n     * 将指定集合中的所有元素插入到此列表中，从指定的位置开始。\n     */\n    public boolean addAll(int index, Collection<? extends E> c) {\n        rangeCheckForAdd(index);\n\n        Object[] a = c.toArray();\n        int numNew = a.length;\n        ensureCapacityInternal(size + numNew);  // Increments modCount\n\n        int numMoved = size - index;\n        if (numMoved > 0)\n            System.arraycopy(elementData, index, elementData, index + numNew,\n                    numMoved);\n\n        System.arraycopy(a, 0, elementData, index, numNew);\n        size += numNew;\n        return numNew != 0;\n    }\n\n    /**\n     * 从此列表中删除所有索引为fromIndex （含）和toIndex之间的元素。\n     * 将任何后续元素移动到左侧（减少其索引）。\n     */\n    protected void removeRange(int fromIndex, int toIndex) {\n        modCount++;\n        int numMoved = size - toIndex;\n        System.arraycopy(elementData, toIndex, elementData, fromIndex,\n                numMoved);\n\n        // clear to let GC do its work\n        int newSize = size - (toIndex - fromIndex);\n        for (int i = newSize; i < size; i++) {\n            elementData[i] = null;\n        }\n        size = newSize;\n    }\n\n    /**\n     * 检查给定的索引是否在范围内。\n     */\n    private void rangeCheck(int index) {\n        if (index >= size)\n            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n    }\n\n    /**\n     * add和addAll使用的rangeCheck的一个版本\n     */\n    private void rangeCheckForAdd(int index) {\n        if (index > size || index < 0)\n            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n    }\n\n    /**\n     * 返回IndexOutOfBoundsException细节信息\n     */\n    private String outOfBoundsMsg(int index) {\n        return \"Index: \" + index + \", Size: \" + size;\n    }\n\n    /**\n     * 从此列表中删除指定集合中包含的所有元素。\n     */\n    public boolean removeAll(Collection<?> c) {\n        Objects.requireNonNull(c);\n        //如果此列表被修改则返回true\n        return batchRemove(c, false);\n    }\n\n    /**\n     * 仅保留此列表中包含在指定集合中的元素。\n     * 换句话说，从此列表中删除其中不包含在指定集合中的所有元素。\n     */\n    public boolean retainAll(Collection<?> c) {\n        Objects.requireNonNull(c);\n        return batchRemove(c, true);\n    }\n\n\n    /**\n     * 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。\n     * 指定的索引表示初始调用将返回的第一个元素为next 。 初始调用previous将返回指定索引减1的元素。\n     * 返回的列表迭代器是fail-fast 。\n     */\n    public ListIterator<E> listIterator(int index) {\n        if (index < 0 || index > size)\n            throw new IndexOutOfBoundsException(\"Index: \" + index);\n        return new ListItr(index);\n    }\n\n    /**\n     * 返回列表中的列表迭代器（按适当的顺序）。\n     * 返回的列表迭代器是fail-fast 。\n     */\n    public ListIterator<E> listIterator() {\n        return new ListItr(0);\n    }\n\n    /**\n     * 以正确的顺序返回该列表中的元素的迭代器。\n     * 返回的迭代器是fail-fast 。\n     */\n    public Iterator<E> iterator() {\n        return new Itr();\n    }\n```\n\n## ArrayList 扩容机制分析\n\n### 先从 ArrayList 的构造函数说起\n\nArrayList 有三种方式来初始化，构造方法源码如下（JDK8）：\n\n```java\n/**\n * 默认初始容量大小\n */\nprivate static final int DEFAULT_CAPACITY = 10;\n\nprivate static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n\n/**\n * 默认构造函数，使用初始容量10构造一个空列表(无参数构造)\n */\npublic ArrayList() {\n    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n}\n\n/**\n * 带初始容量参数的构造函数。（用户自己指定容量）\n */\npublic ArrayList(int initialCapacity) {\n    if (initialCapacity > 0) {//初始容量大于0\n        //创建initialCapacity大小的数组\n        this.elementData = new Object[initialCapacity];\n    } else if (initialCapacity == 0) {//初始容量等于0\n        //创建空数组\n        this.elementData = EMPTY_ELEMENTDATA;\n    } else {//初始容量小于0，抛出异常\n        throw new IllegalArgumentException(\"Illegal Capacity: \" + initialCapacity);\n    }\n}\n\n\n/**\n *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回\n *如果指定的集合为null，throws NullPointerException。\n */\npublic ArrayList(Collection<? extends E> c) {\n    elementData = c.toArray();\n    if ((size = elementData.length) != 0) {\n        // c.toArray might (incorrectly) not return Object[] (see 6260652)\n        if (elementData.getClass() != Object[].class)\n            elementData = Arrays.copyOf(elementData, size, Object[].class);\n    } else {\n        // replace with empty array.\n        this.elementData = EMPTY_ELEMENTDATA;\n    }\n}\n```\n\n细心的同学一定会发现：**以无参数构造方法创建 `ArrayList` 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。** 下面在我们分析 `ArrayList` 扩容时会讲到这一点内容！\n\n> 补充：JDK6 new 无参构造的 `ArrayList` 对象时，直接创建了长度是 10 的 `Object[]` 数组 `elementData` 。\n\n### 一步一步分析 ArrayList 扩容机制\n\n这里以无参构造函数创建的 `ArrayList` 为例分析。\n\n#### add 方法\n\n```java\n/**\n* 将指定的元素追加到此列表的末尾。\n*/\npublic boolean add(E e) {\n    // 加元素之前，先调用ensureCapacityInternal方法\n    ensureCapacityInternal(size + 1);  // Increments modCount!!\n    // 这里看到ArrayList添加元素的实质就相当于为数组赋值\n    elementData[size++] = e;\n    return true;\n}\n```\n\n**注意**：JDK11 移除了 `ensureCapacityInternal()` 和 `ensureExplicitCapacity()` 方法\n\n`ensureCapacityInternal` 方法的源码如下：\n\n```java\n// 根据给定的最小容量和当前数组元素来计算所需容量。\nprivate static int calculateCapacity(Object[] elementData, int minCapacity) {\n    // 如果当前数组元素为空数组（初始情况），返回默认容量和最小容量中的较大值作为所需容量\n    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n        return Math.max(DEFAULT_CAPACITY, minCapacity);\n    }\n    // 否则直接返回最小容量\n    return minCapacity;\n}\n\n// 确保内部容量达到指定的最小容量。\nprivate void ensureCapacityInternal(int minCapacity) {\n    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));\n}\n```\n\n`ensureCapacityInternal` 方法非常简单，内部直接调用了 `ensureExplicitCapacity` 方法：\n\n```java\n//判断是否需要扩容\nprivate void ensureExplicitCapacity(int minCapacity) {\n    modCount++;\n    //判断当前数组容量是否足以存储minCapacity个元素\n    if (minCapacity - elementData.length > 0)\n        //调用grow方法进行扩容\n        grow(minCapacity);\n}\n```\n\n我们来仔细分析一下：\n\n- 当我们要 `add` 进第 1 个元素到 `ArrayList` 时，`elementData.length` 为 0 （因为还是一个空的 list），因为执行了 `ensureCapacityInternal()` 方法 ，所以 `minCapacity` 此时为 10。此时，`minCapacity - elementData.length > 0`成立，所以会进入 `grow(minCapacity)` 方法。\n- 当 `add` 第 2 个元素时，`minCapacity` 为 2，此时 `elementData.length`(容量)在添加第一个元素后扩容成 `10` 了。此时，`minCapacity - elementData.length > 0` 不成立，所以不会进入 （执行）`grow(minCapacity)` 方法。\n- 添加第 3、4···到第 10 个元素时，依然不会执行 grow 方法，数组容量都为 10。\n\n直到添加第 11 个元素，`minCapacity`(为 11)比 `elementData.length`（为 10）要大。进入 `grow` 方法进行扩容。\n\n#### grow 方法\n\n```java\n/**\n * 要分配的最大数组大小\n */\nprivate static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n\n/**\n * ArrayList扩容的核心方法。\n */\nprivate void grow(int minCapacity) {\n    // oldCapacity为旧容量，newCapacity为新容量\n    int oldCapacity = elementData.length;\n    // 将oldCapacity 右移一位，其效果相当于oldCapacity /2，\n    // 我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，\n    int newCapacity = oldCapacity + (oldCapacity >> 1);\n\n    // 然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，\n    if (newCapacity - minCapacity < 0)\n        newCapacity = minCapacity;\n\n    // 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，\n    // 如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。\n    if (newCapacity - MAX_ARRAY_SIZE > 0)\n        newCapacity = hugeCapacity(minCapacity);\n\n    // minCapacity is usually close to size, so this is a win:\n    elementData = Arrays.copyOf(elementData, newCapacity);\n}\n```\n\n**`int newCapacity = oldCapacity + (oldCapacity >> 1)`,所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！** 奇偶不同，比如：10+10/2 = 15, 33+33/2=49。如果是奇数的话会丢掉小数.\n\n> \">>\"（移位运算符）：>>1 右移一位相当于除 2，右移 n 位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了 1 位所以相当于 oldCapacity /2。对于大数据的 2 进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已,不去计算,这样提高了效率,节省了资源\n\n**我们再来通过例子探究一下`grow()` 方法：**\n\n- 当 `add` 第 1 个元素时，`oldCapacity` 为 0，经比较后第一个 if 判断成立，`newCapacity = minCapacity`(为 10)。但是第二个 if 判断不会成立，即 `newCapacity` 不比 `MAX_ARRAY_SIZE` 大，则不会进入 `hugeCapacity` 方法。数组容量为 10，`add` 方法中 return true,size 增为 1。\n- 当 `add` 第 11 个元素进入 `grow` 方法时，`newCapacity` 为 15，比 `minCapacity`（为 11）大，第一个 if 判断不成立。新容量没有大于数组最大 size，不会进入 `hugeCapacity` 方法。数组容量扩为 15，add 方法中 return true,size 增为 11。\n- 以此类推······\n\n**这里补充一点比较重要，但是容易被忽视掉的知识点：**\n\n- Java 中的 `length`属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.\n- Java 中的 `length()` 方法是针对字符串说的,如果想看这个字符串的长度则用到 `length()` 这个方法.\n- Java 中的 `size()` 方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!\n\n#### hugeCapacity() 方法\n\n从上面 `grow()` 方法源码我们知道：如果新容量大于 `MAX_ARRAY_SIZE`,进入(执行) `hugeCapacity()` 方法来比较 `minCapacity` 和 `MAX_ARRAY_SIZE`，如果 `minCapacity` 大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 `MAX_ARRAY_SIZE` 即为 `Integer.MAX_VALUE - 8`。\n\n```java\nprivate static int hugeCapacity(int minCapacity) {\n    if (minCapacity < 0) // overflow\n        throw new OutOfMemoryError();\n    // 对minCapacity和MAX_ARRAY_SIZE进行比较\n    // 若minCapacity大，将Integer.MAX_VALUE作为新数组的大小\n    // 若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小\n    // MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n    return (minCapacity > MAX_ARRAY_SIZE) ?\n        Integer.MAX_VALUE :\n        MAX_ARRAY_SIZE;\n}\n```\n\n### `System.arraycopy()` 和 `Arrays.copyOf()`方法\n\n阅读源码的话，我们就会发现 `ArrayList` 中大量调用了这两个方法。比如：我们上面讲的扩容操作以及`add(int index, E element)`、`toArray()` 等方法中都用到了该方法！\n\n#### `System.arraycopy()` 方法\n\n源码：\n\n```java\n    // 我们发现 arraycopy 是一个 native 方法,接下来我们解释一下各个参数的具体意义\n    /**\n    *   复制数组\n    * @param src 源数组\n    * @param srcPos 源数组中的起始位置\n    * @param dest 目标数组\n    * @param destPos 目标数组中的起始位置\n    * @param length 要复制的数组元素的数量\n    */\n    public static native void arraycopy(Object src,  int  srcPos,\n                                        Object dest, int destPos,\n                                        int length);\n```\n\n场景：\n\n```java\n    /**\n     * 在此列表中的指定位置插入指定的元素。\n     *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；\n     *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。\n     */\n    public void add(int index, E element) {\n        rangeCheckForAdd(index);\n\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        //arraycopy()方法实现数组自己复制自己\n        //elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；\n        System.arraycopy(elementData, index, elementData, index + 1, size - index);\n        elementData[index] = element;\n        size++;\n    }\n```\n\n我们写一个简单的方法测试以下：\n\n```java\npublic class ArraycopyTest {\n\n  public static void main(String[] args) {\n    // TODO Auto-generated method stub\n    int[] a = new int[10];\n    a[0] = 0;\n    a[1] = 1;\n    a[2] = 2;\n    a[3] = 3;\n    System.arraycopy(a, 2, a, 3, 3);\n    a[2]=99;\n    for (int i = 0; i < a.length; i++) {\n      System.out.print(a[i] + \" \");\n    }\n  }\n\n}\n```\n\n结果：\n\n```plain\n0 1 99 2 3 0 0 0 0 0\n```\n\n#### `Arrays.copyOf()`方法\n\n源码：\n\n```java\n    public static int[] copyOf(int[] original, int newLength) {\n      // 申请一个新的数组\n        int[] copy = new int[newLength];\n  // 调用System.arraycopy,将源数组中的数据进行拷贝,并返回新的数组\n        System.arraycopy(original, 0, copy, 0,\n                         Math.min(original.length, newLength));\n        return copy;\n    }\n```\n\n场景：\n\n```java\n   /**\n     以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型。\n     */\n    public Object[] toArray() {\n    //elementData：要复制的数组；size：要复制的长度\n        return Arrays.copyOf(elementData, size);\n    }\n```\n\n个人觉得使用 `Arrays.copyOf()`方法主要是为了给原有数组扩容，测试代码如下：\n\n```java\npublic class ArrayscopyOfTest {\n\n  public static void main(String[] args) {\n    int[] a = new int[3];\n    a[0] = 0;\n    a[1] = 1;\n    a[2] = 2;\n    int[] b = Arrays.copyOf(a, 10);\n    System.out.println(\"b.length\"+b.length);\n  }\n}\n```\n\n结果：\n\n```plain\n10\n```\n\n#### 两者联系和区别\n\n**联系：**\n\n看两者源代码可以发现 `copyOf()`内部实际调用了 `System.arraycopy()` 方法\n\n**区别：**\n\n`arraycopy()` 需要目标数组，将原数组拷贝到你自己定义的数组里或者原数组，而且可以选择拷贝的起点和长度以及放入新数组中的位置 `copyOf()` 是系统自动在内部新建一个数组，并返回该数组。\n\n### `ensureCapacity`方法\n\n`ArrayList` 源码中有一个 `ensureCapacity` 方法不知道大家注意到没有，这个方法 `ArrayList` 内部没有被调用过，所以很显然是提供给用户调用的，那么这个方法有什么作用呢？\n\n```java\n    /**\n    如有必要，增加此 ArrayList 实例的容量，以确保它至少可以容纳由minimum capacity参数指定的元素数。\n     *\n     * @param   minCapacity   所需的最小容量\n     */\n    public void ensureCapacity(int minCapacity) {\n        int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)\n            // any size if not default element table\n            ? 0\n            // larger than default for default empty table. It's already\n            // supposed to be at default size.\n            : DEFAULT_CAPACITY;\n\n        if (minCapacity > minExpand) {\n            ensureExplicitCapacity(minCapacity);\n        }\n    }\n\n```\n\n理论上来说，最好在向 `ArrayList` 添加大量元素之前用 `ensureCapacity` 方法，以减少增量重新分配的次数\n\n我们通过下面的代码实际测试以下这个方法的效果：\n\n```java\npublic class EnsureCapacityTest {\n  public static void main(String[] args) {\n    ArrayList<Object> list = new ArrayList<Object>();\n    final int N = 10000000;\n    long startTime = System.currentTimeMillis();\n    for (int i = 0; i < N; i++) {\n      list.add(i);\n    }\n    long endTime = System.currentTimeMillis();\n    System.out.println(\"使用ensureCapacity方法前：\"+(endTime - startTime));\n\n  }\n}\n```\n\n运行结果：\n\n```plain\n使用ensureCapacity方法前：2158\n```\n\n```java\npublic class EnsureCapacityTest {\n    public static void main(String[] args) {\n        ArrayList<Object> list = new ArrayList<Object>();\n        final int N = 10000000;\n        long startTime1 = System.currentTimeMillis();\n        list.ensureCapacity(N);\n        for (int i = 0; i < N; i++) {\n            list.add(i);\n        }\n        long endTime1 = System.currentTimeMillis();\n        System.out.println(\"使用ensureCapacity方法后：\"+(endTime1 - startTime1));\n    }\n}\n```\n\n运行结果：\n\n```plain\n使用ensureCapacity方法后：1773\n```\n\n通过运行结果，我们可以看出向 `ArrayList` 添加大量元素之前使用`ensureCapacity` 方法可以提升性能。不过，这个性能差距几乎可以忽略不计。而且，实际项目根本也不可能往 `ArrayList` 里面添加这么多元素。","slug":"Java/collection/arraylist-source-code","published":1,"updated":"2025-12-27T14:21:45.716Z","__permalink":"/Java/collection/","comments":1,"layout":"post","photos":[],"_id":"cuid5GMpqeHLyCaHHNFwvFduH","content":"<h2 id=\"ArrayList-简介\"><a href=\"#ArrayList-简介\" class=\"headerlink\" title=\"ArrayList 简介\"></a>ArrayList 简介</h2><p><code>ArrayList</code> 的底层是数组队列，相当于动态数组。与 Java 中的数组相比，它的容量能动态增长。在添加大量元素前，应用程序可以使用<code>ensureCapacity</code>操作来增加 <code>ArrayList</code> 实例的容量。这可以减少递增式再分配的数量。</p>\n<p><code>ArrayList</code> 继承于 <code>AbstractList</code> ，实现了 <code>List</code>, <code>RandomAccess</code>, <code>Cloneable</code>, <code>java.io.Serializable</code> 这些接口。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ArrayList</span>&lt;E&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractList</span>&lt;E&gt;</span><br><span class=\"line\">        <span class=\"keyword\">implements</span> <span class=\"title class_\">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>List</code> : 表明它是一个列表，支持添加、删除、查找等操作，并且可以通过下标进行访问。</li>\n<li><code>RandomAccess</code> ：这是一个标志接口，表明实现这个接口的 <code>List</code> 集合是支持 <strong>快速随机访问</strong> 的。在 <code>ArrayList</code> 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。</li>\n<li><code>Cloneable</code> ：表明它具有拷贝能力，可以进行深拷贝或浅拷贝操作。</li>\n<li><code>Serializable</code> : 表明它可以进行序列化操作，也就是可以将对象转换为字节流进行持久化存储或网络传输，非常方便。</li>\n</ul>\n<h3 id=\"ArrayList-和-Vector-的区别-（了解即可）\"><a href=\"#ArrayList-和-Vector-的区别-（了解即可）\" class=\"headerlink\" title=\"ArrayList 和 Vector 的区别?（了解即可）\"></a>ArrayList 和 Vector 的区别?（了解即可）</h3><ul>\n<li><code>ArrayList</code> 是 <code>List</code> 的主要实现类，底层使用 <code>Object[]</code>存储，适用于频繁的查找工作，线程不安全 。</li>\n<li><code>Vector</code> 是 <code>List</code> 的古老实现类，底层使用<code>Object[]</code> 存储，线程安全。</li>\n</ul>\n<h3 id=\"ArrayList-可以添加-null-值吗？\"><a href=\"#ArrayList-可以添加-null-值吗？\" class=\"headerlink\" title=\"ArrayList 可以添加 null 值吗？\"></a>ArrayList 可以添加 null 值吗？</h3><p><code>ArrayList</code> 中可以存储任何类型的对象，包括 <code>null</code> 值。不过，不建议向<code>ArrayList</code> 中添加 <code>null</code> 值， <code>null</code> 值无意义，会让代码难以维护比如忘记做判空处理就会导致空指针异常。</p>\n<p>示例代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ArrayList&lt;String&gt; listOfStrings = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">listOfStrings.add(<span class=\"literal\">null</span>);</span><br><span class=\"line\">listOfStrings.add(<span class=\"string\">&quot;java&quot;</span>);</span><br><span class=\"line\">System.out.println(listOfStrings);</span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[null, java]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Arraylist-与-LinkedList-区别\"><a href=\"#Arraylist-与-LinkedList-区别\" class=\"headerlink\" title=\"Arraylist 与 LinkedList 区别?\"></a>Arraylist 与 LinkedList 区别?</h3><ul>\n<li><strong>是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</li>\n<li><strong>底层数据结构：</strong> <code>ArrayList</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</li>\n<li><strong>插入和删除是否受元素位置的影响：</strong><ul>\n<li><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>），时间复杂度就为 O(n)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位&#x2F;向前移一位的操作。</li>\n<li><code>LinkedList</code> 采用链表存储，所以在头尾插入或者删除元素不受元素位置的影响（<code>add(E e)</code>、<code>addFirst(E e)</code>、<code>addLast(E e)</code>、<code>removeFirst()</code>、 <code>removeLast()</code>），时间复杂度为 O(1)，如果是要在指定位置 <code>i</code> 插入和删除元素的话（<code>add(int index, E element)</code>，<code>remove(Object o)</code>,<code>remove(int index)</code>）， 时间复杂度为 O(n) ，因为需要先移动到指定位置再插入和删除。</li>\n</ul>\n</li>\n<li><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code>（实现了 <code>RandomAccess</code> 接口） 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</li>\n<li><strong>内存空间占用：</strong> <code>ArrayList</code> 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li>\n</ul>\n<h2 id=\"ArrayList-核心源码解读\"><a href=\"#ArrayList-核心源码解读\" class=\"headerlink\" title=\"ArrayList 核心源码解读\"></a>ArrayList 核心源码解读</h2><p>这里以 JDK1.8 为例，分析一下 <code>ArrayList</code> 的底层源码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br><span class=\"line\">322</span><br><span class=\"line\">323</span><br><span class=\"line\">324</span><br><span class=\"line\">325</span><br><span class=\"line\">326</span><br><span class=\"line\">327</span><br><span class=\"line\">328</span><br><span class=\"line\">329</span><br><span class=\"line\">330</span><br><span class=\"line\">331</span><br><span class=\"line\">332</span><br><span class=\"line\">333</span><br><span class=\"line\">334</span><br><span class=\"line\">335</span><br><span class=\"line\">336</span><br><span class=\"line\">337</span><br><span class=\"line\">338</span><br><span class=\"line\">339</span><br><span class=\"line\">340</span><br><span class=\"line\">341</span><br><span class=\"line\">342</span><br><span class=\"line\">343</span><br><span class=\"line\">344</span><br><span class=\"line\">345</span><br><span class=\"line\">346</span><br><span class=\"line\">347</span><br><span class=\"line\">348</span><br><span class=\"line\">349</span><br><span class=\"line\">350</span><br><span class=\"line\">351</span><br><span class=\"line\">352</span><br><span class=\"line\">353</span><br><span class=\"line\">354</span><br><span class=\"line\">355</span><br><span class=\"line\">356</span><br><span class=\"line\">357</span><br><span class=\"line\">358</span><br><span class=\"line\">359</span><br><span class=\"line\">360</span><br><span class=\"line\">361</span><br><span class=\"line\">362</span><br><span class=\"line\">363</span><br><span class=\"line\">364</span><br><span class=\"line\">365</span><br><span class=\"line\">366</span><br><span class=\"line\">367</span><br><span class=\"line\">368</span><br><span class=\"line\">369</span><br><span class=\"line\">370</span><br><span class=\"line\">371</span><br><span class=\"line\">372</span><br><span class=\"line\">373</span><br><span class=\"line\">374</span><br><span class=\"line\">375</span><br><span class=\"line\">376</span><br><span class=\"line\">377</span><br><span class=\"line\">378</span><br><span class=\"line\">379</span><br><span class=\"line\">380</span><br><span class=\"line\">381</span><br><span class=\"line\">382</span><br><span class=\"line\">383</span><br><span class=\"line\">384</span><br><span class=\"line\">385</span><br><span class=\"line\">386</span><br><span class=\"line\">387</span><br><span class=\"line\">388</span><br><span class=\"line\">389</span><br><span class=\"line\">390</span><br><span class=\"line\">391</span><br><span class=\"line\">392</span><br><span class=\"line\">393</span><br><span class=\"line\">394</span><br><span class=\"line\">395</span><br><span class=\"line\">396</span><br><span class=\"line\">397</span><br><span class=\"line\">398</span><br><span class=\"line\">399</span><br><span class=\"line\">400</span><br><span class=\"line\">401</span><br><span class=\"line\">402</span><br><span class=\"line\">403</span><br><span class=\"line\">404</span><br><span class=\"line\">405</span><br><span class=\"line\">406</span><br><span class=\"line\">407</span><br><span class=\"line\">408</span><br><span class=\"line\">409</span><br><span class=\"line\">410</span><br><span class=\"line\">411</span><br><span class=\"line\">412</span><br><span class=\"line\">413</span><br><span class=\"line\">414</span><br><span class=\"line\">415</span><br><span class=\"line\">416</span><br><span class=\"line\">417</span><br><span class=\"line\">418</span><br><span class=\"line\">419</span><br><span class=\"line\">420</span><br><span class=\"line\">421</span><br><span class=\"line\">422</span><br><span class=\"line\">423</span><br><span class=\"line\">424</span><br><span class=\"line\">425</span><br><span class=\"line\">426</span><br><span class=\"line\">427</span><br><span class=\"line\">428</span><br><span class=\"line\">429</span><br><span class=\"line\">430</span><br><span class=\"line\">431</span><br><span class=\"line\">432</span><br><span class=\"line\">433</span><br><span class=\"line\">434</span><br><span class=\"line\">435</span><br><span class=\"line\">436</span><br><span class=\"line\">437</span><br><span class=\"line\">438</span><br><span class=\"line\">439</span><br><span class=\"line\">440</span><br><span class=\"line\">441</span><br><span class=\"line\">442</span><br><span class=\"line\">443</span><br><span class=\"line\">444</span><br><span class=\"line\">445</span><br><span class=\"line\">446</span><br><span class=\"line\">447</span><br><span class=\"line\">448</span><br><span class=\"line\">449</span><br><span class=\"line\">450</span><br><span class=\"line\">451</span><br><span class=\"line\">452</span><br><span class=\"line\">453</span><br><span class=\"line\">454</span><br><span class=\"line\">455</span><br><span class=\"line\">456</span><br><span class=\"line\">457</span><br><span class=\"line\">458</span><br><span class=\"line\">459</span><br><span class=\"line\">460</span><br><span class=\"line\">461</span><br><span class=\"line\">462</span><br><span class=\"line\">463</span><br><span class=\"line\">464</span><br><span class=\"line\">465</span><br><span class=\"line\">466</span><br><span class=\"line\">467</span><br><span class=\"line\">468</span><br><span class=\"line\">469</span><br><span class=\"line\">470</span><br><span class=\"line\">471</span><br><span class=\"line\">472</span><br><span class=\"line\">473</span><br><span class=\"line\">474</span><br><span class=\"line\">475</span><br><span class=\"line\">476</span><br><span class=\"line\">477</span><br><span class=\"line\">478</span><br><span class=\"line\">479</span><br><span class=\"line\">480</span><br><span class=\"line\">481</span><br><span class=\"line\">482</span><br><span class=\"line\">483</span><br><span class=\"line\">484</span><br><span class=\"line\">485</span><br><span class=\"line\">486</span><br><span class=\"line\">487</span><br><span class=\"line\">488</span><br><span class=\"line\">489</span><br><span class=\"line\">490</span><br><span class=\"line\">491</span><br><span class=\"line\">492</span><br><span class=\"line\">493</span><br><span class=\"line\">494</span><br><span class=\"line\">495</span><br><span class=\"line\">496</span><br><span class=\"line\">497</span><br><span class=\"line\">498</span><br><span class=\"line\">499</span><br><span class=\"line\">500</span><br><span class=\"line\">501</span><br><span class=\"line\">502</span><br><span class=\"line\">503</span><br><span class=\"line\">504</span><br><span class=\"line\">505</span><br><span class=\"line\">506</span><br><span class=\"line\">507</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ArrayList</span>&lt;E&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractList</span>&lt;E&gt;</span><br><span class=\"line\">        <span class=\"keyword\">implements</span> <span class=\"title class_\">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">serialVersionUID</span> <span class=\"operator\">=</span> <span class=\"number\">8683452581122892189L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 默认初始容量大小</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DEFAULT_CAPACITY</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 空数组（用于空实例）。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用于默认大小空实例的共享空数组实例。</span></span><br><span class=\"line\">    <span class=\"comment\">//我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 保存ArrayList数据的数组</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">transient</span> Object[] elementData; <span class=\"comment\">// non-private to simplify nested class access</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * ArrayList 所包含的元素个数</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> size;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 带初始容量参数的构造函数（用户可以在创建ArrayList对象时自己指定集合的初始大小）</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ArrayList</span><span class=\"params\">(<span class=\"type\">int</span> initialCapacity)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (initialCapacity &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果传入的参数大于0，创建initialCapacity大小的数组</span></span><br><span class=\"line\">            <span class=\"built_in\">this</span>.elementData = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>[initialCapacity];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (initialCapacity == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果传入的参数等于0，创建空数组</span></span><br><span class=\"line\">            <span class=\"built_in\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//其他情况，抛出异常</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;Illegal Capacity: &quot;</span> +</span><br><span class=\"line\">                    initialCapacity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 默认无参构造函数</span></span><br><span class=\"line\"><span class=\"comment\">     * DEFAULTCAPACITY_EMPTY_ELEMENTDATA 为0.初始化为10，也就是说初始其实是空数组 当添加第一个元素的时候数组容量才变成10</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ArrayList</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ArrayList</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//将指定集合转换为数组</span></span><br><span class=\"line\">        elementData = c.toArray();</span><br><span class=\"line\">        <span class=\"comment\">//如果elementData数组的长度不为0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((size = elementData.length) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果elementData不是Object类型数据（c.toArray可能返回的不是Object类型的数组所以加上下面的语句用于判断）</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (elementData.getClass() != Object[].class)</span><br><span class=\"line\">                <span class=\"comment\">//将原来不是Object类型的elementData数组的内容，赋值给新的Object类型的elementData数组</span></span><br><span class=\"line\">                elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 其他情况，用空数组代替</span></span><br><span class=\"line\">            <span class=\"built_in\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 修改这个ArrayList实例的容量是列表的当前大小。 应用程序可以使用此操作来最小化ArrayList实例的存储。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">trimToSize</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (size &lt; elementData.length) &#123;</span><br><span class=\"line\">            elementData = (size == <span class=\"number\">0</span>)</span><br><span class=\"line\">                    ? EMPTY_ELEMENTDATA</span><br><span class=\"line\">                    : Arrays.copyOf(elementData, size);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">//下面是ArrayList的扩容机制</span></span><br><span class=\"line\"><span class=\"comment\">//ArrayList的扩容机制提高了性能，如果每次只扩充一个，</span></span><br><span class=\"line\"><span class=\"comment\">//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> minCapacity 所需的最小容量</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">ensureCapacity</span><span class=\"params\">(<span class=\"type\">int</span> minCapacity)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果不是默认空数组，则minExpand的值为0；</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果是默认空数组，则minExpand的值为10</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">minExpand</span> <span class=\"operator\">=</span> (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class=\"line\">                <span class=\"comment\">// 如果不是默认元素表，则可以使用任意大小</span></span><br><span class=\"line\">                ? <span class=\"number\">0</span></span><br><span class=\"line\">                <span class=\"comment\">// 如果是默认空数组，它应该已经是默认大小</span></span><br><span class=\"line\">                : DEFAULT_CAPACITY;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果最小容量大于已有的最大容量</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 根据需要的最小容量，确保容量足够</span></span><br><span class=\"line\">            ensureExplicitCapacity(minCapacity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 根据给定的最小容量和当前数组元素来计算所需容量。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">calculateCapacity</span><span class=\"params\">(Object[] elementData, <span class=\"type\">int</span> minCapacity)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果当前数组元素为空数组（初始情况），返回默认容量和最小容量中的较大值作为所需容量</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 否则直接返回最小容量</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> minCapacity;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 确保内部容量达到指定的最小容量。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">ensureCapacityInternal</span><span class=\"params\">(<span class=\"type\">int</span> minCapacity)</span> &#123;</span><br><span class=\"line\">        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//判断是否需要扩容</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">ensureExplicitCapacity</span><span class=\"params\">(<span class=\"type\">int</span> minCapacity)</span> &#123;</span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\">        <span class=\"comment\">// overflow-conscious code</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (minCapacity - elementData.length &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"comment\">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class=\"line\">            grow(minCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 要分配的最大数组大小</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">MAX_ARRAY_SIZE</span> <span class=\"operator\">=</span> Integer.MAX_VALUE - <span class=\"number\">8</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * ArrayList扩容的核心方法。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">grow</span><span class=\"params\">(<span class=\"type\">int</span> minCapacity)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">oldCapacity</span> <span class=\"operator\">=</span> elementData.length;</span><br><span class=\"line\">        <span class=\"comment\">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class=\"line\">        <span class=\"comment\">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">newCapacity</span> <span class=\"operator\">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"comment\">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            newCapacity = minCapacity;</span><br><span class=\"line\">        <span class=\"comment\">//再检查新容量是否超出了ArrayList所定义的最大容量，</span></span><br><span class=\"line\">        <span class=\"comment\">//若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，</span></span><br><span class=\"line\">        <span class=\"comment\">//如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Integer.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">        <span class=\"comment\">// minCapacity is usually close to size, so this is a win:</span></span><br><span class=\"line\">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//比较minCapacity和 MAX_ARRAY_SIZE</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">hugeCapacity</span><span class=\"params\">(<span class=\"type\">int</span> minCapacity)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (minCapacity &lt; <span class=\"number\">0</span>) <span class=\"comment\">// overflow</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">OutOfMemoryError</span>();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class=\"line\">                Integer.MAX_VALUE :</span><br><span class=\"line\">                MAX_ARRAY_SIZE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回此列表中的元素数。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">size</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> size;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 如果此列表不包含元素，则返回 true 。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isEmpty</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//注意=和==的区别</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> size == <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 如果此列表包含指定的元素，则返回true 。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">contains</span><span class=\"params\">(Object o)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//indexOf()方法：返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> indexOf(o) &gt;= <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">indexOf</span><span class=\"params\">(Object o)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; size; i++)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (elementData[i] == <span class=\"literal\">null</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; size; i++)</span><br><span class=\"line\">                <span class=\"comment\">//equals()方法比较</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (o.equals(elementData[i]))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">lastIndexOf</span><span class=\"params\">(Object o)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> size - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (elementData[i] == <span class=\"literal\">null</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> size - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (o.equals(elementData[i]))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回此ArrayList实例的浅拷贝。 （元素本身不被复制。）</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">clone</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class=\"built_in\">super</span>.clone();</span><br><span class=\"line\">            <span class=\"comment\">//Arrays.copyOf功能是实现数组的复制，返回复制后的数组。参数是被复制的数组和复制的长度</span></span><br><span class=\"line\">            v.elementData = Arrays.copyOf(elementData, size);</span><br><span class=\"line\">            v.modCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> v;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 这不应该发生，因为我们是可以克隆的</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InternalError</span>(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回的数组将是“安全的”，因为该列表不保留对它的引用。</span></span><br><span class=\"line\"><span class=\"comment\">     * （换句话说，这个方法必须分配一个新的数组）。</span></span><br><span class=\"line\"><span class=\"comment\">     * 因此，调用者可以自由地修改返回的数组结构。</span></span><br><span class=\"line\"><span class=\"comment\">     * 注意：如果元素是引用类型，修改元素的内容会影响到原列表中的对象。</span></span><br><span class=\"line\"><span class=\"comment\">     * 此方法充当基于数组和基于集合的API之间的桥梁。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object[] toArray() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Arrays.copyOf(elementData, size);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）;</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回的数组的运行时类型是指定数组的运行时类型。 如果列表适合指定的数组，则返回其中。</span></span><br><span class=\"line\"><span class=\"comment\">     * 否则，将为指定数组的运行时类型和此列表的大小分配一个新数组。</span></span><br><span class=\"line\"><span class=\"comment\">     * 如果列表适用于指定的数组，其余空间（即数组的列表数量多于此元素），则紧跟在集合结束后的数组中的元素设置为null 。</span></span><br><span class=\"line\"><span class=\"comment\">     * （这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度。）</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a.length &lt; size)</span><br><span class=\"line\">            <span class=\"comment\">// 新建一个运行时类型的数组，但是ArrayList数组的内容</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class=\"line\">        <span class=\"comment\">//调用System提供的arraycopy()方法实现数组之间的复制</span></span><br><span class=\"line\">        System.arraycopy(elementData, <span class=\"number\">0</span>, a, <span class=\"number\">0</span>, size);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a.length &gt; size)</span><br><span class=\"line\">            a[size] = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Positional Access Operations</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\">    E <span class=\"title function_\">elementData</span><span class=\"params\">(<span class=\"type\">int</span> index)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (E) elementData[index];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回此列表中指定位置的元素。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> E <span class=\"title function_\">get</span><span class=\"params\">(<span class=\"type\">int</span> index)</span> &#123;</span><br><span class=\"line\">        rangeCheck(index);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> elementData(index);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 用指定的元素替换此列表中指定位置的元素。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> E <span class=\"title function_\">set</span><span class=\"params\">(<span class=\"type\">int</span> index, E element)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//对index进行界限检查</span></span><br><span class=\"line\">        rangeCheck(index);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">E</span> <span class=\"variable\">oldValue</span> <span class=\"operator\">=</span> elementData(index);</span><br><span class=\"line\">        elementData[index] = element;</span><br><span class=\"line\">        <span class=\"comment\">//返回原来在这个位置的元素</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 将指定的元素追加到此列表的末尾。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">add</span><span class=\"params\">(E e)</span> &#123;</span><br><span class=\"line\">        ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></span><br><span class=\"line\">        <span class=\"comment\">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class=\"line\">        elementData[size++] = e;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 在此列表中的指定位置插入指定的元素。</span></span><br><span class=\"line\"><span class=\"comment\">     * 先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；</span></span><br><span class=\"line\"><span class=\"comment\">     * 再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">add</span><span class=\"params\">(<span class=\"type\">int</span> index, E element)</span> &#123;</span><br><span class=\"line\">        rangeCheckForAdd(index);</span><br><span class=\"line\"></span><br><span class=\"line\">        ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></span><br><span class=\"line\">        <span class=\"comment\">//arraycopy()这个实现数组之间复制的方法一定要看一下，下面就用到了arraycopy()方法实现数组自己复制自己</span></span><br><span class=\"line\">        System.arraycopy(elementData, index, elementData, index + <span class=\"number\">1</span>,</span><br><span class=\"line\">                size - index);</span><br><span class=\"line\">        elementData[index] = element;</span><br><span class=\"line\">        size++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 删除该列表中指定位置的元素。 将任何后续元素移动到左侧（从其索引中减去一个元素）。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> E <span class=\"title function_\">remove</span><span class=\"params\">(<span class=\"type\">int</span> index)</span> &#123;</span><br><span class=\"line\">        rangeCheck(index);</span><br><span class=\"line\"></span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\">        <span class=\"type\">E</span> <span class=\"variable\">oldValue</span> <span class=\"operator\">=</span> elementData(index);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">numMoved</span> <span class=\"operator\">=</span> size - index - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (numMoved &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            System.arraycopy(elementData, index + <span class=\"number\">1</span>, elementData, index,</span><br><span class=\"line\">                    numMoved);</span><br><span class=\"line\">        elementData[--size] = <span class=\"literal\">null</span>; <span class=\"comment\">// clear to let GC do its work</span></span><br><span class=\"line\">        <span class=\"comment\">//从列表中删除的元素</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 从列表中删除指定元素的第一个出现（如果存在）。 如果列表不包含该元素，则它不会更改。</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回true，如果此列表包含指定的元素</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">remove</span><span class=\"params\">(Object o)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; index &lt; size; index++)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (elementData[index] == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                    fastRemove(index);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; index &lt; size; index++)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (o.equals(elementData[index])) &#123;</span><br><span class=\"line\">                    fastRemove(index);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * 该方法为私有的移除方法，跳过了边界检查，并且不返回被移除的值。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fastRemove</span><span class=\"params\">(<span class=\"type\">int</span> index)</span> &#123;</span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">numMoved</span> <span class=\"operator\">=</span> size - index - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (numMoved &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            System.arraycopy(elementData, index + <span class=\"number\">1</span>, elementData, index,</span><br><span class=\"line\">                    numMoved);</span><br><span class=\"line\">        elementData[--size] = <span class=\"literal\">null</span>; <span class=\"comment\">// 在移除元素后，将该位置的元素设为 null，以便垃圾回收器（GC）能够回收该元素。</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 从列表中删除所有元素。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">clear</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 把数组中所有的元素的值设为null</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; size; i++)</span><br><span class=\"line\">            elementData[i] = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        size = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">addAll</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class=\"line\">        Object[] a = c.toArray();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">numNew</span> <span class=\"operator\">=</span> a.length;</span><br><span class=\"line\">        ensureCapacityInternal(size + numNew);  <span class=\"comment\">// Increments modCount</span></span><br><span class=\"line\">        System.arraycopy(a, <span class=\"number\">0</span>, elementData, size, numNew);</span><br><span class=\"line\">        size += numNew;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> numNew != <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 将指定集合中的所有元素插入到此列表中，从指定的位置开始。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">addAll</span><span class=\"params\">(<span class=\"type\">int</span> index, Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class=\"line\">        rangeCheckForAdd(index);</span><br><span class=\"line\"></span><br><span class=\"line\">        Object[] a = c.toArray();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">numNew</span> <span class=\"operator\">=</span> a.length;</span><br><span class=\"line\">        ensureCapacityInternal(size + numNew);  <span class=\"comment\">// Increments modCount</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">numMoved</span> <span class=\"operator\">=</span> size - index;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (numMoved &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class=\"line\">                    numMoved);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.arraycopy(a, <span class=\"number\">0</span>, elementData, index, numNew);</span><br><span class=\"line\">        size += numNew;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> numNew != <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 从此列表中删除所有索引为fromIndex （含）和toIndex之间的元素。</span></span><br><span class=\"line\"><span class=\"comment\">     * 将任何后续元素移动到左侧（减少其索引）。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">removeRange</span><span class=\"params\">(<span class=\"type\">int</span> fromIndex, <span class=\"type\">int</span> toIndex)</span> &#123;</span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">numMoved</span> <span class=\"operator\">=</span> size - toIndex;</span><br><span class=\"line\">        System.arraycopy(elementData, toIndex, elementData, fromIndex,</span><br><span class=\"line\">                numMoved);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// clear to let GC do its work</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">newSize</span> <span class=\"operator\">=</span> size - (toIndex - fromIndex);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> newSize; i &lt; size; i++) &#123;</span><br><span class=\"line\">            elementData[i] = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        size = newSize;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 检查给定的索引是否在范围内。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">rangeCheck</span><span class=\"params\">(<span class=\"type\">int</span> index)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &gt;= size)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * add和addAll使用的rangeCheck的一个版本</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">rangeCheckForAdd</span><span class=\"params\">(<span class=\"type\">int</span> index)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &gt; size || index &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回IndexOutOfBoundsException细节信息</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String <span class=\"title function_\">outOfBoundsMsg</span><span class=\"params\">(<span class=\"type\">int</span> index)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Index: &quot;</span> + index + <span class=\"string\">&quot;, Size: &quot;</span> + size;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 从此列表中删除指定集合中包含的所有元素。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">removeAll</span><span class=\"params\">(Collection&lt;?&gt; c)</span> &#123;</span><br><span class=\"line\">        Objects.requireNonNull(c);</span><br><span class=\"line\">        <span class=\"comment\">//如果此列表被修改则返回true</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> batchRemove(c, <span class=\"literal\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 仅保留此列表中包含在指定集合中的元素。</span></span><br><span class=\"line\"><span class=\"comment\">     * 换句话说，从此列表中删除其中不包含在指定集合中的所有元素。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">retainAll</span><span class=\"params\">(Collection&lt;?&gt; c)</span> &#123;</span><br><span class=\"line\">        Objects.requireNonNull(c);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> batchRemove(c, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。</span></span><br><span class=\"line\"><span class=\"comment\">     * 指定的索引表示初始调用将返回的第一个元素为next 。 初始调用previous将返回指定索引减1的元素。</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回的列表迭代器是fail-fast 。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ListIterator&lt;E&gt; <span class=\"title function_\">listIterator</span><span class=\"params\">(<span class=\"type\">int</span> index)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &lt; <span class=\"number\">0</span> || index &gt; size)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IndexOutOfBoundsException</span>(<span class=\"string\">&quot;Index: &quot;</span> + index);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ListItr</span>(index);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回列表中的列表迭代器（按适当的顺序）。</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回的列表迭代器是fail-fast 。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ListIterator&lt;E&gt; <span class=\"title function_\">listIterator</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ListItr</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 以正确的顺序返回该列表中的元素的迭代器。</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回的迭代器是fail-fast 。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Iterator&lt;E&gt; <span class=\"title function_\">iterator</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Itr</span>();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"ArrayList-扩容机制分析\"><a href=\"#ArrayList-扩容机制分析\" class=\"headerlink\" title=\"ArrayList 扩容机制分析\"></a>ArrayList 扩容机制分析</h2><h3 id=\"先从-ArrayList-的构造函数说起\"><a href=\"#先从-ArrayList-的构造函数说起\" class=\"headerlink\" title=\"先从 ArrayList 的构造函数说起\"></a>先从 ArrayList 的构造函数说起</h3><p>ArrayList 有三种方式来初始化，构造方法源码如下（JDK8）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 默认初始容量大小</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DEFAULT_CAPACITY</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 默认构造函数，使用初始容量10构造一个空列表(无参数构造)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">ArrayList</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 带初始容量参数的构造函数。（用户自己指定容量）</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">ArrayList</span><span class=\"params\">(<span class=\"type\">int</span> initialCapacity)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initialCapacity &gt; <span class=\"number\">0</span>) &#123;<span class=\"comment\">//初始容量大于0</span></span><br><span class=\"line\">        <span class=\"comment\">//创建initialCapacity大小的数组</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.elementData = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>[initialCapacity];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (initialCapacity == <span class=\"number\">0</span>) &#123;<span class=\"comment\">//初始容量等于0</span></span><br><span class=\"line\">        <span class=\"comment\">//创建空数组</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;<span class=\"comment\">//初始容量小于0，抛出异常</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;Illegal Capacity: &quot;</span> + initialCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回</span></span><br><span class=\"line\"><span class=\"comment\"> *如果指定的集合为null，throws NullPointerException。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">ArrayList</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class=\"line\">    elementData = c.toArray();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((size = elementData.length) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (elementData.getClass() != Object[].class)</span><br><span class=\"line\">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// replace with empty array.</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>细心的同学一定会发现：<strong>以无参数构造方法创建 <code>ArrayList</code> 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。</strong> 下面在我们分析 <code>ArrayList</code> 扩容时会讲到这一点内容！</p>\n<blockquote>\n<p>补充：JDK6 new 无参构造的 <code>ArrayList</code> 对象时，直接创建了长度是 10 的 <code>Object[]</code> 数组 <code>elementData</code> 。</p>\n</blockquote>\n<h3 id=\"一步一步分析-ArrayList-扩容机制\"><a href=\"#一步一步分析-ArrayList-扩容机制\" class=\"headerlink\" title=\"一步一步分析 ArrayList 扩容机制\"></a>一步一步分析 ArrayList 扩容机制</h3><p>这里以无参构造函数创建的 <code>ArrayList</code> 为例分析。</p>\n<h4 id=\"add-方法\"><a href=\"#add-方法\" class=\"headerlink\" title=\"add 方法\"></a>add 方法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 将指定的元素追加到此列表的末尾。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">add</span><span class=\"params\">(E e)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 加元素之前，先调用ensureCapacityInternal方法</span></span><br><span class=\"line\">    ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></span><br><span class=\"line\">    <span class=\"comment\">// 这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class=\"line\">    elementData[size++] = e;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意</strong>：JDK11 移除了 <code>ensureCapacityInternal()</code> 和 <code>ensureExplicitCapacity()</code> 方法</p>\n<p><code>ensureCapacityInternal</code> 方法的源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 根据给定的最小容量和当前数组元素来计算所需容量。</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">calculateCapacity</span><span class=\"params\">(Object[] elementData, <span class=\"type\">int</span> minCapacity)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果当前数组元素为空数组（初始情况），返回默认容量和最小容量中的较大值作为所需容量</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 否则直接返回最小容量</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> minCapacity;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 确保内部容量达到指定的最小容量。</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">ensureCapacityInternal</span><span class=\"params\">(<span class=\"type\">int</span> minCapacity)</span> &#123;</span><br><span class=\"line\">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>ensureCapacityInternal</code> 方法非常简单，内部直接调用了 <code>ensureExplicitCapacity</code> 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//判断是否需要扩容</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">ensureExplicitCapacity</span><span class=\"params\">(<span class=\"type\">int</span> minCapacity)</span> &#123;</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    <span class=\"comment\">//判断当前数组容量是否足以存储minCapacity个元素</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minCapacity - elementData.length &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"comment\">//调用grow方法进行扩容</span></span><br><span class=\"line\">        grow(minCapacity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们来仔细分析一下：</p>\n<ul>\n<li>当我们要 <code>add</code> 进第 1 个元素到 <code>ArrayList</code> 时，<code>elementData.length</code> 为 0 （因为还是一个空的 list），因为执行了 <code>ensureCapacityInternal()</code> 方法 ，所以 <code>minCapacity</code> 此时为 10。此时，<code>minCapacity - elementData.length &gt; 0</code>成立，所以会进入 <code>grow(minCapacity)</code> 方法。</li>\n<li>当 <code>add</code> 第 2 个元素时，<code>minCapacity</code> 为 2，此时 <code>elementData.length</code>(容量)在添加第一个元素后扩容成 <code>10</code> 了。此时，<code>minCapacity - elementData.length &gt; 0</code> 不成立，所以不会进入 （执行）<code>grow(minCapacity)</code> 方法。</li>\n<li>添加第 3、4···到第 10 个元素时，依然不会执行 grow 方法，数组容量都为 10。</li>\n</ul>\n<p>直到添加第 11 个元素，<code>minCapacity</code>(为 11)比 <code>elementData.length</code>（为 10）要大。进入 <code>grow</code> 方法进行扩容。</p>\n<h4 id=\"grow-方法\"><a href=\"#grow-方法\" class=\"headerlink\" title=\"grow 方法\"></a>grow 方法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 要分配的最大数组大小</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">MAX_ARRAY_SIZE</span> <span class=\"operator\">=</span> Integer.MAX_VALUE - <span class=\"number\">8</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * ArrayList扩容的核心方法。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">grow</span><span class=\"params\">(<span class=\"type\">int</span> minCapacity)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">oldCapacity</span> <span class=\"operator\">=</span> elementData.length;</span><br><span class=\"line\">    <span class=\"comment\">// 将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class=\"line\">    <span class=\"comment\">// 我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">newCapacity</span> <span class=\"operator\">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = minCapacity;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// minCapacity is usually close to size, so this is a win:</span></span><br><span class=\"line\">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong><code>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)</code>,所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！</strong> 奇偶不同，比如：10+10&#x2F;2 &#x3D; 15, 33+33&#x2F;2&#x3D;49。如果是奇数的话会丢掉小数.</p>\n<blockquote>\n<p>“&gt;&gt;”（移位运算符）：&gt;&gt;1 右移一位相当于除 2，右移 n 位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了 1 位所以相当于 oldCapacity &#x2F;2。对于大数据的 2 进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已,不去计算,这样提高了效率,节省了资源</p>\n</blockquote>\n<p><strong>我们再来通过例子探究一下<code>grow()</code> 方法：</strong></p>\n<ul>\n<li>当 <code>add</code> 第 1 个元素时，<code>oldCapacity</code> 为 0，经比较后第一个 if 判断成立，<code>newCapacity = minCapacity</code>(为 10)。但是第二个 if 判断不会成立，即 <code>newCapacity</code> 不比 <code>MAX_ARRAY_SIZE</code> 大，则不会进入 <code>hugeCapacity</code> 方法。数组容量为 10，<code>add</code> 方法中 return true,size 增为 1。</li>\n<li>当 <code>add</code> 第 11 个元素进入 <code>grow</code> 方法时，<code>newCapacity</code> 为 15，比 <code>minCapacity</code>（为 11）大，第一个 if 判断不成立。新容量没有大于数组最大 size，不会进入 <code>hugeCapacity</code> 方法。数组容量扩为 15，add 方法中 return true,size 增为 11。</li>\n<li>以此类推······</li>\n</ul>\n<p><strong>这里补充一点比较重要，但是容易被忽视掉的知识点：</strong></p>\n<ul>\n<li>Java 中的 <code>length</code>属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.</li>\n<li>Java 中的 <code>length()</code> 方法是针对字符串说的,如果想看这个字符串的长度则用到 <code>length()</code> 这个方法.</li>\n<li>Java 中的 <code>size()</code> 方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!</li>\n</ul>\n<h4 id=\"hugeCapacity-方法\"><a href=\"#hugeCapacity-方法\" class=\"headerlink\" title=\"hugeCapacity() 方法\"></a>hugeCapacity() 方法</h4><p>从上面 <code>grow()</code> 方法源码我们知道：如果新容量大于 <code>MAX_ARRAY_SIZE</code>,进入(执行) <code>hugeCapacity()</code> 方法来比较 <code>minCapacity</code> 和 <code>MAX_ARRAY_SIZE</code>，如果 <code>minCapacity</code> 大于最大容量，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 <code>MAX_ARRAY_SIZE</code> 即为 <code>Integer.MAX_VALUE - 8</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">hugeCapacity</span><span class=\"params\">(<span class=\"type\">int</span> minCapacity)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minCapacity &lt; <span class=\"number\">0</span>) <span class=\"comment\">// overflow</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">OutOfMemoryError</span>();</span><br><span class=\"line\">    <span class=\"comment\">// 对minCapacity和MAX_ARRAY_SIZE进行比较</span></span><br><span class=\"line\">    <span class=\"comment\">// 若minCapacity大，将Integer.MAX_VALUE作为新数组的大小</span></span><br><span class=\"line\">    <span class=\"comment\">// 若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小</span></span><br><span class=\"line\">    <span class=\"comment\">// MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class=\"line\">        Integer.MAX_VALUE :</span><br><span class=\"line\">        MAX_ARRAY_SIZE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"System-arraycopy-和-Arrays-copyOf-方法\"><a href=\"#System-arraycopy-和-Arrays-copyOf-方法\" class=\"headerlink\" title=\"System.arraycopy() 和 Arrays.copyOf()方法\"></a><code>System.arraycopy()</code> 和 <code>Arrays.copyOf()</code>方法</h3><p>阅读源码的话，我们就会发现 <code>ArrayList</code> 中大量调用了这两个方法。比如：我们上面讲的扩容操作以及<code>add(int index, E element)</code>、<code>toArray()</code> 等方法中都用到了该方法！</p>\n<h4 id=\"System-arraycopy-方法\"><a href=\"#System-arraycopy-方法\" class=\"headerlink\" title=\"System.arraycopy() 方法\"></a><code>System.arraycopy()</code> 方法</h4><p>源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 我们发现 arraycopy 是一个 native 方法,接下来我们解释一下各个参数的具体意义</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">*   复制数组</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span> src 源数组</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span> srcPos 源数组中的起始位置</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span> dest 目标数组</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span> destPos 目标数组中的起始位置</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span> length 要复制的数组元素的数量</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title function_\">arraycopy</span><span class=\"params\">(Object src,  <span class=\"type\">int</span>  srcPos,</span></span><br><span class=\"line\"><span class=\"params\">                                    Object dest, <span class=\"type\">int</span> destPos,</span></span><br><span class=\"line\"><span class=\"params\">                                    <span class=\"type\">int</span> length)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>场景：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 在此列表中的指定位置插入指定的元素。</span></span><br><span class=\"line\"><span class=\"comment\"> *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；</span></span><br><span class=\"line\"><span class=\"comment\"> *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">add</span><span class=\"params\">(<span class=\"type\">int</span> index, E element)</span> &#123;</span><br><span class=\"line\">    rangeCheckForAdd(index);</span><br><span class=\"line\"></span><br><span class=\"line\">    ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></span><br><span class=\"line\">    <span class=\"comment\">//arraycopy()方法实现数组自己复制自己</span></span><br><span class=\"line\">    <span class=\"comment\">//elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；</span></span><br><span class=\"line\">    System.arraycopy(elementData, index, elementData, index + <span class=\"number\">1</span>, size - index);</span><br><span class=\"line\">    elementData[index] = element;</span><br><span class=\"line\">    size++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们写一个简单的方法测试以下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ArraycopyTest</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">    <span class=\"type\">int</span>[] a = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">10</span>];</span><br><span class=\"line\">    a[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    a[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    a[<span class=\"number\">2</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\">    a[<span class=\"number\">3</span>] = <span class=\"number\">3</span>;</span><br><span class=\"line\">    System.arraycopy(a, <span class=\"number\">2</span>, a, <span class=\"number\">3</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">    a[<span class=\"number\">2</span>]=<span class=\"number\">99</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; a.length; i++) &#123;</span><br><span class=\"line\">      System.out.print(a[i] + <span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0 1 99 2 3 0 0 0 0 0</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Arrays-copyOf-方法\"><a href=\"#Arrays-copyOf-方法\" class=\"headerlink\" title=\"Arrays.copyOf()方法\"></a><code>Arrays.copyOf()</code>方法</h4><p>源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span>[] copyOf(<span class=\"type\">int</span>[] original, <span class=\"type\">int</span> newLength) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 申请一个新的数组</span></span><br><span class=\"line\">      <span class=\"type\">int</span>[] copy = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[newLength];</span><br><span class=\"line\"><span class=\"comment\">// 调用System.arraycopy,将源数组中的数据进行拷贝,并返回新的数组</span></span><br><span class=\"line\">      System.arraycopy(original, <span class=\"number\">0</span>, copy, <span class=\"number\">0</span>,</span><br><span class=\"line\">                       Math.min(original.length, newLength));</span><br><span class=\"line\">      <span class=\"keyword\">return</span> copy;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>场景：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型。</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span> Object[] toArray() &#123;</span><br><span class=\"line\"> <span class=\"comment\">//elementData：要复制的数组；size：要复制的长度</span></span><br><span class=\"line\">     <span class=\"keyword\">return</span> Arrays.copyOf(elementData, size);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>个人觉得使用 <code>Arrays.copyOf()</code>方法主要是为了给原有数组扩容，测试代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ArrayscopyOfTest</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span>[] a = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">3</span>];</span><br><span class=\"line\">    a[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    a[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    a[<span class=\"number\">2</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span>[] b = Arrays.copyOf(a, <span class=\"number\">10</span>);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;b.length&quot;</span>+b.length);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"两者联系和区别\"><a href=\"#两者联系和区别\" class=\"headerlink\" title=\"两者联系和区别\"></a>两者联系和区别</h4><p><strong>联系：</strong></p>\n<p>看两者源代码可以发现 <code>copyOf()</code>内部实际调用了 <code>System.arraycopy()</code> 方法</p>\n<p><strong>区别：</strong></p>\n<p><code>arraycopy()</code> 需要目标数组，将原数组拷贝到你自己定义的数组里或者原数组，而且可以选择拷贝的起点和长度以及放入新数组中的位置 <code>copyOf()</code> 是系统自动在内部新建一个数组，并返回该数组。</p>\n<h3 id=\"ensureCapacity方法\"><a href=\"#ensureCapacity方法\" class=\"headerlink\" title=\"ensureCapacity方法\"></a><code>ensureCapacity</code>方法</h3><p><code>ArrayList</code> 源码中有一个 <code>ensureCapacity</code> 方法不知道大家注意到没有，这个方法 <code>ArrayList</code> 内部没有被调用过，所以很显然是提供给用户调用的，那么这个方法有什么作用呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">如有必要，增加此 ArrayList 实例的容量，以确保它至少可以容纳由minimum capacity参数指定的元素数。</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span>   minCapacity   所需的最小容量</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">ensureCapacity</span><span class=\"params\">(<span class=\"type\">int</span> minCapacity)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">minExpand</span> <span class=\"operator\">=</span> (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class=\"line\">        <span class=\"comment\">// any size if not default element table</span></span><br><span class=\"line\">        ? <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"comment\">// larger than default for default empty table. It&#x27;s already</span></span><br><span class=\"line\">        <span class=\"comment\">// supposed to be at default size.</span></span><br><span class=\"line\">        : DEFAULT_CAPACITY;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class=\"line\">        ensureExplicitCapacity(minCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>理论上来说，最好在向 <code>ArrayList</code> 添加大量元素之前用 <code>ensureCapacity</code> 方法，以减少增量重新分配的次数</p>\n<p>我们通过下面的代码实际测试以下这个方法的效果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">EnsureCapacityTest</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    ArrayList&lt;Object&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;Object&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">N</span> <span class=\"operator\">=</span> <span class=\"number\">10000000</span>;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">startTime</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; N; i++) &#123;</span><br><span class=\"line\">      list.add(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">endTime</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;使用ensureCapacity方法前：&quot;</span>+(endTime - startTime));</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用ensureCapacity方法前：2158</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">EnsureCapacityTest</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        ArrayList&lt;Object&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;Object&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">N</span> <span class=\"operator\">=</span> <span class=\"number\">10000000</span>;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">startTime1</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">        list.ensureCapacity(N);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; N; i++) &#123;</span><br><span class=\"line\">            list.add(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">endTime1</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;使用ensureCapacity方法后：&quot;</span>+(endTime1 - startTime1));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用ensureCapacity方法后：1773</span><br></pre></td></tr></table></figure>\n\n<p>通过运行结果，我们可以看出向 <code>ArrayList</code> 添加大量元素之前使用<code>ensureCapacity</code> 方法可以提升性能。不过，这个性能差距几乎可以忽略不计。而且，实际项目根本也不可能往 <code>ArrayList</code> 里面添加这么多元素。</p>\n","excerpt":"","more":"<h2 id=\"ArrayList-简介\"><a href=\"#ArrayList-简介\" class=\"headerlink\" title=\"ArrayList 简介\"></a>ArrayList 简介</h2><p><code>ArrayList</code> 的底层是数组队列，相当于动态数组。与 Java 中的数组相比，它的容量能动态增长。在添加大量元素前，应用程序可以使用<code>ensureCapacity</code>操作来增加 <code>ArrayList</code> 实例的容量。这可以减少递增式再分配的数量。</p>\n<p><code>ArrayList</code> 继承于 <code>AbstractList</code> ，实现了 <code>List</code>, <code>RandomAccess</code>, <code>Cloneable</code>, <code>java.io.Serializable</code> 这些接口。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ArrayList</span>&lt;E&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractList</span>&lt;E&gt;</span><br><span class=\"line\">        <span class=\"keyword\">implements</span> <span class=\"title class_\">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>List</code> : 表明它是一个列表，支持添加、删除、查找等操作，并且可以通过下标进行访问。</li>\n<li><code>RandomAccess</code> ：这是一个标志接口，表明实现这个接口的 <code>List</code> 集合是支持 <strong>快速随机访问</strong> 的。在 <code>ArrayList</code> 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。</li>\n<li><code>Cloneable</code> ：表明它具有拷贝能力，可以进行深拷贝或浅拷贝操作。</li>\n<li><code>Serializable</code> : 表明它可以进行序列化操作，也就是可以将对象转换为字节流进行持久化存储或网络传输，非常方便。</li>\n</ul>\n<h3 id=\"ArrayList-和-Vector-的区别-（了解即可）\"><a href=\"#ArrayList-和-Vector-的区别-（了解即可）\" class=\"headerlink\" title=\"ArrayList 和 Vector 的区别?（了解即可）\"></a>ArrayList 和 Vector 的区别?（了解即可）</h3><ul>\n<li><code>ArrayList</code> 是 <code>List</code> 的主要实现类，底层使用 <code>Object[]</code>存储，适用于频繁的查找工作，线程不安全 。</li>\n<li><code>Vector</code> 是 <code>List</code> 的古老实现类，底层使用<code>Object[]</code> 存储，线程安全。</li>\n</ul>\n<h3 id=\"ArrayList-可以添加-null-值吗？\"><a href=\"#ArrayList-可以添加-null-值吗？\" class=\"headerlink\" title=\"ArrayList 可以添加 null 值吗？\"></a>ArrayList 可以添加 null 值吗？</h3><p><code>ArrayList</code> 中可以存储任何类型的对象，包括 <code>null</code> 值。不过，不建议向<code>ArrayList</code> 中添加 <code>null</code> 值， <code>null</code> 值无意义，会让代码难以维护比如忘记做判空处理就会导致空指针异常。</p>\n<p>示例代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ArrayList&lt;String&gt; listOfStrings = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">listOfStrings.add(<span class=\"literal\">null</span>);</span><br><span class=\"line\">listOfStrings.add(<span class=\"string\">&quot;java&quot;</span>);</span><br><span class=\"line\">System.out.println(listOfStrings);</span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[null, java]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Arraylist-与-LinkedList-区别\"><a href=\"#Arraylist-与-LinkedList-区别\" class=\"headerlink\" title=\"Arraylist 与 LinkedList 区别?\"></a>Arraylist 与 LinkedList 区别?</h3><ul>\n<li><strong>是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</li>\n<li><strong>底层数据结构：</strong> <code>ArrayList</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</li>\n<li><strong>插入和删除是否受元素位置的影响：</strong><ul>\n<li><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>），时间复杂度就为 O(n)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位&#x2F;向前移一位的操作。</li>\n<li><code>LinkedList</code> 采用链表存储，所以在头尾插入或者删除元素不受元素位置的影响（<code>add(E e)</code>、<code>addFirst(E e)</code>、<code>addLast(E e)</code>、<code>removeFirst()</code>、 <code>removeLast()</code>），时间复杂度为 O(1)，如果是要在指定位置 <code>i</code> 插入和删除元素的话（<code>add(int index, E element)</code>，<code>remove(Object o)</code>,<code>remove(int index)</code>）， 时间复杂度为 O(n) ，因为需要先移动到指定位置再插入和删除。</li>\n</ul>\n</li>\n<li><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code>（实现了 <code>RandomAccess</code> 接口） 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</li>\n<li><strong>内存空间占用：</strong> <code>ArrayList</code> 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li>\n</ul>\n<h2 id=\"ArrayList-核心源码解读\"><a href=\"#ArrayList-核心源码解读\" class=\"headerlink\" title=\"ArrayList 核心源码解读\"></a>ArrayList 核心源码解读</h2><p>这里以 JDK1.8 为例，分析一下 <code>ArrayList</code> 的底层源码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br><span class=\"line\">322</span><br><span class=\"line\">323</span><br><span class=\"line\">324</span><br><span class=\"line\">325</span><br><span class=\"line\">326</span><br><span class=\"line\">327</span><br><span class=\"line\">328</span><br><span class=\"line\">329</span><br><span class=\"line\">330</span><br><span class=\"line\">331</span><br><span class=\"line\">332</span><br><span class=\"line\">333</span><br><span class=\"line\">334</span><br><span class=\"line\">335</span><br><span class=\"line\">336</span><br><span class=\"line\">337</span><br><span class=\"line\">338</span><br><span class=\"line\">339</span><br><span class=\"line\">340</span><br><span class=\"line\">341</span><br><span class=\"line\">342</span><br><span class=\"line\">343</span><br><span class=\"line\">344</span><br><span class=\"line\">345</span><br><span class=\"line\">346</span><br><span class=\"line\">347</span><br><span class=\"line\">348</span><br><span class=\"line\">349</span><br><span class=\"line\">350</span><br><span class=\"line\">351</span><br><span class=\"line\">352</span><br><span class=\"line\">353</span><br><span class=\"line\">354</span><br><span class=\"line\">355</span><br><span class=\"line\">356</span><br><span class=\"line\">357</span><br><span class=\"line\">358</span><br><span class=\"line\">359</span><br><span class=\"line\">360</span><br><span class=\"line\">361</span><br><span class=\"line\">362</span><br><span class=\"line\">363</span><br><span class=\"line\">364</span><br><span class=\"line\">365</span><br><span class=\"line\">366</span><br><span class=\"line\">367</span><br><span class=\"line\">368</span><br><span class=\"line\">369</span><br><span class=\"line\">370</span><br><span class=\"line\">371</span><br><span class=\"line\">372</span><br><span class=\"line\">373</span><br><span class=\"line\">374</span><br><span class=\"line\">375</span><br><span class=\"line\">376</span><br><span class=\"line\">377</span><br><span class=\"line\">378</span><br><span class=\"line\">379</span><br><span class=\"line\">380</span><br><span class=\"line\">381</span><br><span class=\"line\">382</span><br><span class=\"line\">383</span><br><span class=\"line\">384</span><br><span class=\"line\">385</span><br><span class=\"line\">386</span><br><span class=\"line\">387</span><br><span class=\"line\">388</span><br><span class=\"line\">389</span><br><span class=\"line\">390</span><br><span class=\"line\">391</span><br><span class=\"line\">392</span><br><span class=\"line\">393</span><br><span class=\"line\">394</span><br><span class=\"line\">395</span><br><span class=\"line\">396</span><br><span class=\"line\">397</span><br><span class=\"line\">398</span><br><span class=\"line\">399</span><br><span class=\"line\">400</span><br><span class=\"line\">401</span><br><span class=\"line\">402</span><br><span class=\"line\">403</span><br><span class=\"line\">404</span><br><span class=\"line\">405</span><br><span class=\"line\">406</span><br><span class=\"line\">407</span><br><span class=\"line\">408</span><br><span class=\"line\">409</span><br><span class=\"line\">410</span><br><span class=\"line\">411</span><br><span class=\"line\">412</span><br><span class=\"line\">413</span><br><span class=\"line\">414</span><br><span class=\"line\">415</span><br><span class=\"line\">416</span><br><span class=\"line\">417</span><br><span class=\"line\">418</span><br><span class=\"line\">419</span><br><span class=\"line\">420</span><br><span class=\"line\">421</span><br><span class=\"line\">422</span><br><span class=\"line\">423</span><br><span class=\"line\">424</span><br><span class=\"line\">425</span><br><span class=\"line\">426</span><br><span class=\"line\">427</span><br><span class=\"line\">428</span><br><span class=\"line\">429</span><br><span class=\"line\">430</span><br><span class=\"line\">431</span><br><span class=\"line\">432</span><br><span class=\"line\">433</span><br><span class=\"line\">434</span><br><span class=\"line\">435</span><br><span class=\"line\">436</span><br><span class=\"line\">437</span><br><span class=\"line\">438</span><br><span class=\"line\">439</span><br><span class=\"line\">440</span><br><span class=\"line\">441</span><br><span class=\"line\">442</span><br><span class=\"line\">443</span><br><span class=\"line\">444</span><br><span class=\"line\">445</span><br><span class=\"line\">446</span><br><span class=\"line\">447</span><br><span class=\"line\">448</span><br><span class=\"line\">449</span><br><span class=\"line\">450</span><br><span class=\"line\">451</span><br><span class=\"line\">452</span><br><span class=\"line\">453</span><br><span class=\"line\">454</span><br><span class=\"line\">455</span><br><span class=\"line\">456</span><br><span class=\"line\">457</span><br><span class=\"line\">458</span><br><span class=\"line\">459</span><br><span class=\"line\">460</span><br><span class=\"line\">461</span><br><span class=\"line\">462</span><br><span class=\"line\">463</span><br><span class=\"line\">464</span><br><span class=\"line\">465</span><br><span class=\"line\">466</span><br><span class=\"line\">467</span><br><span class=\"line\">468</span><br><span class=\"line\">469</span><br><span class=\"line\">470</span><br><span class=\"line\">471</span><br><span class=\"line\">472</span><br><span class=\"line\">473</span><br><span class=\"line\">474</span><br><span class=\"line\">475</span><br><span class=\"line\">476</span><br><span class=\"line\">477</span><br><span class=\"line\">478</span><br><span class=\"line\">479</span><br><span class=\"line\">480</span><br><span class=\"line\">481</span><br><span class=\"line\">482</span><br><span class=\"line\">483</span><br><span class=\"line\">484</span><br><span class=\"line\">485</span><br><span class=\"line\">486</span><br><span class=\"line\">487</span><br><span class=\"line\">488</span><br><span class=\"line\">489</span><br><span class=\"line\">490</span><br><span class=\"line\">491</span><br><span class=\"line\">492</span><br><span class=\"line\">493</span><br><span class=\"line\">494</span><br><span class=\"line\">495</span><br><span class=\"line\">496</span><br><span class=\"line\">497</span><br><span class=\"line\">498</span><br><span class=\"line\">499</span><br><span class=\"line\">500</span><br><span class=\"line\">501</span><br><span class=\"line\">502</span><br><span class=\"line\">503</span><br><span class=\"line\">504</span><br><span class=\"line\">505</span><br><span class=\"line\">506</span><br><span class=\"line\">507</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ArrayList</span>&lt;E&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractList</span>&lt;E&gt;</span><br><span class=\"line\">        <span class=\"keyword\">implements</span> <span class=\"title class_\">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">serialVersionUID</span> <span class=\"operator\">=</span> <span class=\"number\">8683452581122892189L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 默认初始容量大小</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DEFAULT_CAPACITY</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 空数组（用于空实例）。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用于默认大小空实例的共享空数组实例。</span></span><br><span class=\"line\">    <span class=\"comment\">//我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 保存ArrayList数据的数组</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">transient</span> Object[] elementData; <span class=\"comment\">// non-private to simplify nested class access</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * ArrayList 所包含的元素个数</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> size;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 带初始容量参数的构造函数（用户可以在创建ArrayList对象时自己指定集合的初始大小）</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ArrayList</span><span class=\"params\">(<span class=\"type\">int</span> initialCapacity)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (initialCapacity &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果传入的参数大于0，创建initialCapacity大小的数组</span></span><br><span class=\"line\">            <span class=\"built_in\">this</span>.elementData = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>[initialCapacity];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (initialCapacity == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果传入的参数等于0，创建空数组</span></span><br><span class=\"line\">            <span class=\"built_in\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//其他情况，抛出异常</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;Illegal Capacity: &quot;</span> +</span><br><span class=\"line\">                    initialCapacity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 默认无参构造函数</span></span><br><span class=\"line\"><span class=\"comment\">     * DEFAULTCAPACITY_EMPTY_ELEMENTDATA 为0.初始化为10，也就是说初始其实是空数组 当添加第一个元素的时候数组容量才变成10</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ArrayList</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ArrayList</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//将指定集合转换为数组</span></span><br><span class=\"line\">        elementData = c.toArray();</span><br><span class=\"line\">        <span class=\"comment\">//如果elementData数组的长度不为0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((size = elementData.length) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果elementData不是Object类型数据（c.toArray可能返回的不是Object类型的数组所以加上下面的语句用于判断）</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (elementData.getClass() != Object[].class)</span><br><span class=\"line\">                <span class=\"comment\">//将原来不是Object类型的elementData数组的内容，赋值给新的Object类型的elementData数组</span></span><br><span class=\"line\">                elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 其他情况，用空数组代替</span></span><br><span class=\"line\">            <span class=\"built_in\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 修改这个ArrayList实例的容量是列表的当前大小。 应用程序可以使用此操作来最小化ArrayList实例的存储。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">trimToSize</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (size &lt; elementData.length) &#123;</span><br><span class=\"line\">            elementData = (size == <span class=\"number\">0</span>)</span><br><span class=\"line\">                    ? EMPTY_ELEMENTDATA</span><br><span class=\"line\">                    : Arrays.copyOf(elementData, size);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">//下面是ArrayList的扩容机制</span></span><br><span class=\"line\"><span class=\"comment\">//ArrayList的扩容机制提高了性能，如果每次只扩充一个，</span></span><br><span class=\"line\"><span class=\"comment\">//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> minCapacity 所需的最小容量</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">ensureCapacity</span><span class=\"params\">(<span class=\"type\">int</span> minCapacity)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果不是默认空数组，则minExpand的值为0；</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果是默认空数组，则minExpand的值为10</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">minExpand</span> <span class=\"operator\">=</span> (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class=\"line\">                <span class=\"comment\">// 如果不是默认元素表，则可以使用任意大小</span></span><br><span class=\"line\">                ? <span class=\"number\">0</span></span><br><span class=\"line\">                <span class=\"comment\">// 如果是默认空数组，它应该已经是默认大小</span></span><br><span class=\"line\">                : DEFAULT_CAPACITY;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果最小容量大于已有的最大容量</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 根据需要的最小容量，确保容量足够</span></span><br><span class=\"line\">            ensureExplicitCapacity(minCapacity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 根据给定的最小容量和当前数组元素来计算所需容量。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">calculateCapacity</span><span class=\"params\">(Object[] elementData, <span class=\"type\">int</span> minCapacity)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果当前数组元素为空数组（初始情况），返回默认容量和最小容量中的较大值作为所需容量</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 否则直接返回最小容量</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> minCapacity;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 确保内部容量达到指定的最小容量。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">ensureCapacityInternal</span><span class=\"params\">(<span class=\"type\">int</span> minCapacity)</span> &#123;</span><br><span class=\"line\">        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//判断是否需要扩容</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">ensureExplicitCapacity</span><span class=\"params\">(<span class=\"type\">int</span> minCapacity)</span> &#123;</span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\">        <span class=\"comment\">// overflow-conscious code</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (minCapacity - elementData.length &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"comment\">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class=\"line\">            grow(minCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 要分配的最大数组大小</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">MAX_ARRAY_SIZE</span> <span class=\"operator\">=</span> Integer.MAX_VALUE - <span class=\"number\">8</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * ArrayList扩容的核心方法。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">grow</span><span class=\"params\">(<span class=\"type\">int</span> minCapacity)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">oldCapacity</span> <span class=\"operator\">=</span> elementData.length;</span><br><span class=\"line\">        <span class=\"comment\">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class=\"line\">        <span class=\"comment\">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">newCapacity</span> <span class=\"operator\">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"comment\">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            newCapacity = minCapacity;</span><br><span class=\"line\">        <span class=\"comment\">//再检查新容量是否超出了ArrayList所定义的最大容量，</span></span><br><span class=\"line\">        <span class=\"comment\">//若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，</span></span><br><span class=\"line\">        <span class=\"comment\">//如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Integer.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">        <span class=\"comment\">// minCapacity is usually close to size, so this is a win:</span></span><br><span class=\"line\">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//比较minCapacity和 MAX_ARRAY_SIZE</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">hugeCapacity</span><span class=\"params\">(<span class=\"type\">int</span> minCapacity)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (minCapacity &lt; <span class=\"number\">0</span>) <span class=\"comment\">// overflow</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">OutOfMemoryError</span>();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class=\"line\">                Integer.MAX_VALUE :</span><br><span class=\"line\">                MAX_ARRAY_SIZE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回此列表中的元素数。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">size</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> size;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 如果此列表不包含元素，则返回 true 。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isEmpty</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//注意=和==的区别</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> size == <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 如果此列表包含指定的元素，则返回true 。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">contains</span><span class=\"params\">(Object o)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//indexOf()方法：返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> indexOf(o) &gt;= <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">indexOf</span><span class=\"params\">(Object o)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; size; i++)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (elementData[i] == <span class=\"literal\">null</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; size; i++)</span><br><span class=\"line\">                <span class=\"comment\">//equals()方法比较</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (o.equals(elementData[i]))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">lastIndexOf</span><span class=\"params\">(Object o)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> size - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (elementData[i] == <span class=\"literal\">null</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> size - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (o.equals(elementData[i]))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回此ArrayList实例的浅拷贝。 （元素本身不被复制。）</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">clone</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class=\"built_in\">super</span>.clone();</span><br><span class=\"line\">            <span class=\"comment\">//Arrays.copyOf功能是实现数组的复制，返回复制后的数组。参数是被复制的数组和复制的长度</span></span><br><span class=\"line\">            v.elementData = Arrays.copyOf(elementData, size);</span><br><span class=\"line\">            v.modCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> v;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 这不应该发生，因为我们是可以克隆的</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InternalError</span>(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回的数组将是“安全的”，因为该列表不保留对它的引用。</span></span><br><span class=\"line\"><span class=\"comment\">     * （换句话说，这个方法必须分配一个新的数组）。</span></span><br><span class=\"line\"><span class=\"comment\">     * 因此，调用者可以自由地修改返回的数组结构。</span></span><br><span class=\"line\"><span class=\"comment\">     * 注意：如果元素是引用类型，修改元素的内容会影响到原列表中的对象。</span></span><br><span class=\"line\"><span class=\"comment\">     * 此方法充当基于数组和基于集合的API之间的桥梁。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object[] toArray() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Arrays.copyOf(elementData, size);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）;</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回的数组的运行时类型是指定数组的运行时类型。 如果列表适合指定的数组，则返回其中。</span></span><br><span class=\"line\"><span class=\"comment\">     * 否则，将为指定数组的运行时类型和此列表的大小分配一个新数组。</span></span><br><span class=\"line\"><span class=\"comment\">     * 如果列表适用于指定的数组，其余空间（即数组的列表数量多于此元素），则紧跟在集合结束后的数组中的元素设置为null 。</span></span><br><span class=\"line\"><span class=\"comment\">     * （这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度。）</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a.length &lt; size)</span><br><span class=\"line\">            <span class=\"comment\">// 新建一个运行时类型的数组，但是ArrayList数组的内容</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class=\"line\">        <span class=\"comment\">//调用System提供的arraycopy()方法实现数组之间的复制</span></span><br><span class=\"line\">        System.arraycopy(elementData, <span class=\"number\">0</span>, a, <span class=\"number\">0</span>, size);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a.length &gt; size)</span><br><span class=\"line\">            a[size] = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Positional Access Operations</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\">    E <span class=\"title function_\">elementData</span><span class=\"params\">(<span class=\"type\">int</span> index)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (E) elementData[index];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回此列表中指定位置的元素。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> E <span class=\"title function_\">get</span><span class=\"params\">(<span class=\"type\">int</span> index)</span> &#123;</span><br><span class=\"line\">        rangeCheck(index);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> elementData(index);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 用指定的元素替换此列表中指定位置的元素。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> E <span class=\"title function_\">set</span><span class=\"params\">(<span class=\"type\">int</span> index, E element)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//对index进行界限检查</span></span><br><span class=\"line\">        rangeCheck(index);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">E</span> <span class=\"variable\">oldValue</span> <span class=\"operator\">=</span> elementData(index);</span><br><span class=\"line\">        elementData[index] = element;</span><br><span class=\"line\">        <span class=\"comment\">//返回原来在这个位置的元素</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 将指定的元素追加到此列表的末尾。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">add</span><span class=\"params\">(E e)</span> &#123;</span><br><span class=\"line\">        ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></span><br><span class=\"line\">        <span class=\"comment\">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class=\"line\">        elementData[size++] = e;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 在此列表中的指定位置插入指定的元素。</span></span><br><span class=\"line\"><span class=\"comment\">     * 先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；</span></span><br><span class=\"line\"><span class=\"comment\">     * 再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">add</span><span class=\"params\">(<span class=\"type\">int</span> index, E element)</span> &#123;</span><br><span class=\"line\">        rangeCheckForAdd(index);</span><br><span class=\"line\"></span><br><span class=\"line\">        ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></span><br><span class=\"line\">        <span class=\"comment\">//arraycopy()这个实现数组之间复制的方法一定要看一下，下面就用到了arraycopy()方法实现数组自己复制自己</span></span><br><span class=\"line\">        System.arraycopy(elementData, index, elementData, index + <span class=\"number\">1</span>,</span><br><span class=\"line\">                size - index);</span><br><span class=\"line\">        elementData[index] = element;</span><br><span class=\"line\">        size++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 删除该列表中指定位置的元素。 将任何后续元素移动到左侧（从其索引中减去一个元素）。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> E <span class=\"title function_\">remove</span><span class=\"params\">(<span class=\"type\">int</span> index)</span> &#123;</span><br><span class=\"line\">        rangeCheck(index);</span><br><span class=\"line\"></span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\">        <span class=\"type\">E</span> <span class=\"variable\">oldValue</span> <span class=\"operator\">=</span> elementData(index);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">numMoved</span> <span class=\"operator\">=</span> size - index - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (numMoved &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            System.arraycopy(elementData, index + <span class=\"number\">1</span>, elementData, index,</span><br><span class=\"line\">                    numMoved);</span><br><span class=\"line\">        elementData[--size] = <span class=\"literal\">null</span>; <span class=\"comment\">// clear to let GC do its work</span></span><br><span class=\"line\">        <span class=\"comment\">//从列表中删除的元素</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 从列表中删除指定元素的第一个出现（如果存在）。 如果列表不包含该元素，则它不会更改。</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回true，如果此列表包含指定的元素</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">remove</span><span class=\"params\">(Object o)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; index &lt; size; index++)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (elementData[index] == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                    fastRemove(index);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; index &lt; size; index++)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (o.equals(elementData[index])) &#123;</span><br><span class=\"line\">                    fastRemove(index);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * 该方法为私有的移除方法，跳过了边界检查，并且不返回被移除的值。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fastRemove</span><span class=\"params\">(<span class=\"type\">int</span> index)</span> &#123;</span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">numMoved</span> <span class=\"operator\">=</span> size - index - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (numMoved &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            System.arraycopy(elementData, index + <span class=\"number\">1</span>, elementData, index,</span><br><span class=\"line\">                    numMoved);</span><br><span class=\"line\">        elementData[--size] = <span class=\"literal\">null</span>; <span class=\"comment\">// 在移除元素后，将该位置的元素设为 null，以便垃圾回收器（GC）能够回收该元素。</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 从列表中删除所有元素。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">clear</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 把数组中所有的元素的值设为null</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; size; i++)</span><br><span class=\"line\">            elementData[i] = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        size = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">addAll</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class=\"line\">        Object[] a = c.toArray();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">numNew</span> <span class=\"operator\">=</span> a.length;</span><br><span class=\"line\">        ensureCapacityInternal(size + numNew);  <span class=\"comment\">// Increments modCount</span></span><br><span class=\"line\">        System.arraycopy(a, <span class=\"number\">0</span>, elementData, size, numNew);</span><br><span class=\"line\">        size += numNew;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> numNew != <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 将指定集合中的所有元素插入到此列表中，从指定的位置开始。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">addAll</span><span class=\"params\">(<span class=\"type\">int</span> index, Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class=\"line\">        rangeCheckForAdd(index);</span><br><span class=\"line\"></span><br><span class=\"line\">        Object[] a = c.toArray();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">numNew</span> <span class=\"operator\">=</span> a.length;</span><br><span class=\"line\">        ensureCapacityInternal(size + numNew);  <span class=\"comment\">// Increments modCount</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">numMoved</span> <span class=\"operator\">=</span> size - index;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (numMoved &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class=\"line\">                    numMoved);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.arraycopy(a, <span class=\"number\">0</span>, elementData, index, numNew);</span><br><span class=\"line\">        size += numNew;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> numNew != <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 从此列表中删除所有索引为fromIndex （含）和toIndex之间的元素。</span></span><br><span class=\"line\"><span class=\"comment\">     * 将任何后续元素移动到左侧（减少其索引）。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">removeRange</span><span class=\"params\">(<span class=\"type\">int</span> fromIndex, <span class=\"type\">int</span> toIndex)</span> &#123;</span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">numMoved</span> <span class=\"operator\">=</span> size - toIndex;</span><br><span class=\"line\">        System.arraycopy(elementData, toIndex, elementData, fromIndex,</span><br><span class=\"line\">                numMoved);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// clear to let GC do its work</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">newSize</span> <span class=\"operator\">=</span> size - (toIndex - fromIndex);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> newSize; i &lt; size; i++) &#123;</span><br><span class=\"line\">            elementData[i] = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        size = newSize;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 检查给定的索引是否在范围内。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">rangeCheck</span><span class=\"params\">(<span class=\"type\">int</span> index)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &gt;= size)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * add和addAll使用的rangeCheck的一个版本</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">rangeCheckForAdd</span><span class=\"params\">(<span class=\"type\">int</span> index)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &gt; size || index &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回IndexOutOfBoundsException细节信息</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String <span class=\"title function_\">outOfBoundsMsg</span><span class=\"params\">(<span class=\"type\">int</span> index)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Index: &quot;</span> + index + <span class=\"string\">&quot;, Size: &quot;</span> + size;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 从此列表中删除指定集合中包含的所有元素。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">removeAll</span><span class=\"params\">(Collection&lt;?&gt; c)</span> &#123;</span><br><span class=\"line\">        Objects.requireNonNull(c);</span><br><span class=\"line\">        <span class=\"comment\">//如果此列表被修改则返回true</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> batchRemove(c, <span class=\"literal\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 仅保留此列表中包含在指定集合中的元素。</span></span><br><span class=\"line\"><span class=\"comment\">     * 换句话说，从此列表中删除其中不包含在指定集合中的所有元素。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">retainAll</span><span class=\"params\">(Collection&lt;?&gt; c)</span> &#123;</span><br><span class=\"line\">        Objects.requireNonNull(c);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> batchRemove(c, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。</span></span><br><span class=\"line\"><span class=\"comment\">     * 指定的索引表示初始调用将返回的第一个元素为next 。 初始调用previous将返回指定索引减1的元素。</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回的列表迭代器是fail-fast 。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ListIterator&lt;E&gt; <span class=\"title function_\">listIterator</span><span class=\"params\">(<span class=\"type\">int</span> index)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &lt; <span class=\"number\">0</span> || index &gt; size)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IndexOutOfBoundsException</span>(<span class=\"string\">&quot;Index: &quot;</span> + index);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ListItr</span>(index);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回列表中的列表迭代器（按适当的顺序）。</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回的列表迭代器是fail-fast 。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ListIterator&lt;E&gt; <span class=\"title function_\">listIterator</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ListItr</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 以正确的顺序返回该列表中的元素的迭代器。</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回的迭代器是fail-fast 。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Iterator&lt;E&gt; <span class=\"title function_\">iterator</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Itr</span>();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"ArrayList-扩容机制分析\"><a href=\"#ArrayList-扩容机制分析\" class=\"headerlink\" title=\"ArrayList 扩容机制分析\"></a>ArrayList 扩容机制分析</h2><h3 id=\"先从-ArrayList-的构造函数说起\"><a href=\"#先从-ArrayList-的构造函数说起\" class=\"headerlink\" title=\"先从 ArrayList 的构造函数说起\"></a>先从 ArrayList 的构造函数说起</h3><p>ArrayList 有三种方式来初始化，构造方法源码如下（JDK8）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 默认初始容量大小</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DEFAULT_CAPACITY</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 默认构造函数，使用初始容量10构造一个空列表(无参数构造)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">ArrayList</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 带初始容量参数的构造函数。（用户自己指定容量）</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">ArrayList</span><span class=\"params\">(<span class=\"type\">int</span> initialCapacity)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initialCapacity &gt; <span class=\"number\">0</span>) &#123;<span class=\"comment\">//初始容量大于0</span></span><br><span class=\"line\">        <span class=\"comment\">//创建initialCapacity大小的数组</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.elementData = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>[initialCapacity];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (initialCapacity == <span class=\"number\">0</span>) &#123;<span class=\"comment\">//初始容量等于0</span></span><br><span class=\"line\">        <span class=\"comment\">//创建空数组</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;<span class=\"comment\">//初始容量小于0，抛出异常</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;Illegal Capacity: &quot;</span> + initialCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回</span></span><br><span class=\"line\"><span class=\"comment\"> *如果指定的集合为null，throws NullPointerException。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">ArrayList</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class=\"line\">    elementData = c.toArray();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((size = elementData.length) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (elementData.getClass() != Object[].class)</span><br><span class=\"line\">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// replace with empty array.</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>细心的同学一定会发现：<strong>以无参数构造方法创建 <code>ArrayList</code> 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。</strong> 下面在我们分析 <code>ArrayList</code> 扩容时会讲到这一点内容！</p>\n<blockquote>\n<p>补充：JDK6 new 无参构造的 <code>ArrayList</code> 对象时，直接创建了长度是 10 的 <code>Object[]</code> 数组 <code>elementData</code> 。</p>\n</blockquote>\n<h3 id=\"一步一步分析-ArrayList-扩容机制\"><a href=\"#一步一步分析-ArrayList-扩容机制\" class=\"headerlink\" title=\"一步一步分析 ArrayList 扩容机制\"></a>一步一步分析 ArrayList 扩容机制</h3><p>这里以无参构造函数创建的 <code>ArrayList</code> 为例分析。</p>\n<h4 id=\"add-方法\"><a href=\"#add-方法\" class=\"headerlink\" title=\"add 方法\"></a>add 方法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 将指定的元素追加到此列表的末尾。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">add</span><span class=\"params\">(E e)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 加元素之前，先调用ensureCapacityInternal方法</span></span><br><span class=\"line\">    ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></span><br><span class=\"line\">    <span class=\"comment\">// 这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class=\"line\">    elementData[size++] = e;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意</strong>：JDK11 移除了 <code>ensureCapacityInternal()</code> 和 <code>ensureExplicitCapacity()</code> 方法</p>\n<p><code>ensureCapacityInternal</code> 方法的源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 根据给定的最小容量和当前数组元素来计算所需容量。</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">calculateCapacity</span><span class=\"params\">(Object[] elementData, <span class=\"type\">int</span> minCapacity)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果当前数组元素为空数组（初始情况），返回默认容量和最小容量中的较大值作为所需容量</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 否则直接返回最小容量</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> minCapacity;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 确保内部容量达到指定的最小容量。</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">ensureCapacityInternal</span><span class=\"params\">(<span class=\"type\">int</span> minCapacity)</span> &#123;</span><br><span class=\"line\">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>ensureCapacityInternal</code> 方法非常简单，内部直接调用了 <code>ensureExplicitCapacity</code> 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//判断是否需要扩容</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">ensureExplicitCapacity</span><span class=\"params\">(<span class=\"type\">int</span> minCapacity)</span> &#123;</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    <span class=\"comment\">//判断当前数组容量是否足以存储minCapacity个元素</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minCapacity - elementData.length &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"comment\">//调用grow方法进行扩容</span></span><br><span class=\"line\">        grow(minCapacity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们来仔细分析一下：</p>\n<ul>\n<li>当我们要 <code>add</code> 进第 1 个元素到 <code>ArrayList</code> 时，<code>elementData.length</code> 为 0 （因为还是一个空的 list），因为执行了 <code>ensureCapacityInternal()</code> 方法 ，所以 <code>minCapacity</code> 此时为 10。此时，<code>minCapacity - elementData.length &gt; 0</code>成立，所以会进入 <code>grow(minCapacity)</code> 方法。</li>\n<li>当 <code>add</code> 第 2 个元素时，<code>minCapacity</code> 为 2，此时 <code>elementData.length</code>(容量)在添加第一个元素后扩容成 <code>10</code> 了。此时，<code>minCapacity - elementData.length &gt; 0</code> 不成立，所以不会进入 （执行）<code>grow(minCapacity)</code> 方法。</li>\n<li>添加第 3、4···到第 10 个元素时，依然不会执行 grow 方法，数组容量都为 10。</li>\n</ul>\n<p>直到添加第 11 个元素，<code>minCapacity</code>(为 11)比 <code>elementData.length</code>（为 10）要大。进入 <code>grow</code> 方法进行扩容。</p>\n<h4 id=\"grow-方法\"><a href=\"#grow-方法\" class=\"headerlink\" title=\"grow 方法\"></a>grow 方法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 要分配的最大数组大小</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">MAX_ARRAY_SIZE</span> <span class=\"operator\">=</span> Integer.MAX_VALUE - <span class=\"number\">8</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * ArrayList扩容的核心方法。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">grow</span><span class=\"params\">(<span class=\"type\">int</span> minCapacity)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">oldCapacity</span> <span class=\"operator\">=</span> elementData.length;</span><br><span class=\"line\">    <span class=\"comment\">// 将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class=\"line\">    <span class=\"comment\">// 我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">newCapacity</span> <span class=\"operator\">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = minCapacity;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// minCapacity is usually close to size, so this is a win:</span></span><br><span class=\"line\">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong><code>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)</code>,所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！</strong> 奇偶不同，比如：10+10&#x2F;2 &#x3D; 15, 33+33&#x2F;2&#x3D;49。如果是奇数的话会丢掉小数.</p>\n<blockquote>\n<p>“&gt;&gt;”（移位运算符）：&gt;&gt;1 右移一位相当于除 2，右移 n 位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了 1 位所以相当于 oldCapacity &#x2F;2。对于大数据的 2 进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已,不去计算,这样提高了效率,节省了资源</p>\n</blockquote>\n<p><strong>我们再来通过例子探究一下<code>grow()</code> 方法：</strong></p>\n<ul>\n<li>当 <code>add</code> 第 1 个元素时，<code>oldCapacity</code> 为 0，经比较后第一个 if 判断成立，<code>newCapacity = minCapacity</code>(为 10)。但是第二个 if 判断不会成立，即 <code>newCapacity</code> 不比 <code>MAX_ARRAY_SIZE</code> 大，则不会进入 <code>hugeCapacity</code> 方法。数组容量为 10，<code>add</code> 方法中 return true,size 增为 1。</li>\n<li>当 <code>add</code> 第 11 个元素进入 <code>grow</code> 方法时，<code>newCapacity</code> 为 15，比 <code>minCapacity</code>（为 11）大，第一个 if 判断不成立。新容量没有大于数组最大 size，不会进入 <code>hugeCapacity</code> 方法。数组容量扩为 15，add 方法中 return true,size 增为 11。</li>\n<li>以此类推······</li>\n</ul>\n<p><strong>这里补充一点比较重要，但是容易被忽视掉的知识点：</strong></p>\n<ul>\n<li>Java 中的 <code>length</code>属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.</li>\n<li>Java 中的 <code>length()</code> 方法是针对字符串说的,如果想看这个字符串的长度则用到 <code>length()</code> 这个方法.</li>\n<li>Java 中的 <code>size()</code> 方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!</li>\n</ul>\n<h4 id=\"hugeCapacity-方法\"><a href=\"#hugeCapacity-方法\" class=\"headerlink\" title=\"hugeCapacity() 方法\"></a>hugeCapacity() 方法</h4><p>从上面 <code>grow()</code> 方法源码我们知道：如果新容量大于 <code>MAX_ARRAY_SIZE</code>,进入(执行) <code>hugeCapacity()</code> 方法来比较 <code>minCapacity</code> 和 <code>MAX_ARRAY_SIZE</code>，如果 <code>minCapacity</code> 大于最大容量，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 <code>MAX_ARRAY_SIZE</code> 即为 <code>Integer.MAX_VALUE - 8</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">hugeCapacity</span><span class=\"params\">(<span class=\"type\">int</span> minCapacity)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minCapacity &lt; <span class=\"number\">0</span>) <span class=\"comment\">// overflow</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">OutOfMemoryError</span>();</span><br><span class=\"line\">    <span class=\"comment\">// 对minCapacity和MAX_ARRAY_SIZE进行比较</span></span><br><span class=\"line\">    <span class=\"comment\">// 若minCapacity大，将Integer.MAX_VALUE作为新数组的大小</span></span><br><span class=\"line\">    <span class=\"comment\">// 若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小</span></span><br><span class=\"line\">    <span class=\"comment\">// MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class=\"line\">        Integer.MAX_VALUE :</span><br><span class=\"line\">        MAX_ARRAY_SIZE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"System-arraycopy-和-Arrays-copyOf-方法\"><a href=\"#System-arraycopy-和-Arrays-copyOf-方法\" class=\"headerlink\" title=\"System.arraycopy() 和 Arrays.copyOf()方法\"></a><code>System.arraycopy()</code> 和 <code>Arrays.copyOf()</code>方法</h3><p>阅读源码的话，我们就会发现 <code>ArrayList</code> 中大量调用了这两个方法。比如：我们上面讲的扩容操作以及<code>add(int index, E element)</code>、<code>toArray()</code> 等方法中都用到了该方法！</p>\n<h4 id=\"System-arraycopy-方法\"><a href=\"#System-arraycopy-方法\" class=\"headerlink\" title=\"System.arraycopy() 方法\"></a><code>System.arraycopy()</code> 方法</h4><p>源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 我们发现 arraycopy 是一个 native 方法,接下来我们解释一下各个参数的具体意义</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">*   复制数组</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span> src 源数组</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span> srcPos 源数组中的起始位置</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span> dest 目标数组</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span> destPos 目标数组中的起始位置</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span> length 要复制的数组元素的数量</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title function_\">arraycopy</span><span class=\"params\">(Object src,  <span class=\"type\">int</span>  srcPos,</span></span><br><span class=\"line\"><span class=\"params\">                                    Object dest, <span class=\"type\">int</span> destPos,</span></span><br><span class=\"line\"><span class=\"params\">                                    <span class=\"type\">int</span> length)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>场景：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 在此列表中的指定位置插入指定的元素。</span></span><br><span class=\"line\"><span class=\"comment\"> *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；</span></span><br><span class=\"line\"><span class=\"comment\"> *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">add</span><span class=\"params\">(<span class=\"type\">int</span> index, E element)</span> &#123;</span><br><span class=\"line\">    rangeCheckForAdd(index);</span><br><span class=\"line\"></span><br><span class=\"line\">    ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></span><br><span class=\"line\">    <span class=\"comment\">//arraycopy()方法实现数组自己复制自己</span></span><br><span class=\"line\">    <span class=\"comment\">//elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；</span></span><br><span class=\"line\">    System.arraycopy(elementData, index, elementData, index + <span class=\"number\">1</span>, size - index);</span><br><span class=\"line\">    elementData[index] = element;</span><br><span class=\"line\">    size++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们写一个简单的方法测试以下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ArraycopyTest</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">    <span class=\"type\">int</span>[] a = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">10</span>];</span><br><span class=\"line\">    a[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    a[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    a[<span class=\"number\">2</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\">    a[<span class=\"number\">3</span>] = <span class=\"number\">3</span>;</span><br><span class=\"line\">    System.arraycopy(a, <span class=\"number\">2</span>, a, <span class=\"number\">3</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">    a[<span class=\"number\">2</span>]=<span class=\"number\">99</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; a.length; i++) &#123;</span><br><span class=\"line\">      System.out.print(a[i] + <span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0 1 99 2 3 0 0 0 0 0</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Arrays-copyOf-方法\"><a href=\"#Arrays-copyOf-方法\" class=\"headerlink\" title=\"Arrays.copyOf()方法\"></a><code>Arrays.copyOf()</code>方法</h4><p>源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span>[] copyOf(<span class=\"type\">int</span>[] original, <span class=\"type\">int</span> newLength) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 申请一个新的数组</span></span><br><span class=\"line\">      <span class=\"type\">int</span>[] copy = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[newLength];</span><br><span class=\"line\"><span class=\"comment\">// 调用System.arraycopy,将源数组中的数据进行拷贝,并返回新的数组</span></span><br><span class=\"line\">      System.arraycopy(original, <span class=\"number\">0</span>, copy, <span class=\"number\">0</span>,</span><br><span class=\"line\">                       Math.min(original.length, newLength));</span><br><span class=\"line\">      <span class=\"keyword\">return</span> copy;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>场景：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型。</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span> Object[] toArray() &#123;</span><br><span class=\"line\"> <span class=\"comment\">//elementData：要复制的数组；size：要复制的长度</span></span><br><span class=\"line\">     <span class=\"keyword\">return</span> Arrays.copyOf(elementData, size);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>个人觉得使用 <code>Arrays.copyOf()</code>方法主要是为了给原有数组扩容，测试代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ArrayscopyOfTest</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span>[] a = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">3</span>];</span><br><span class=\"line\">    a[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    a[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    a[<span class=\"number\">2</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span>[] b = Arrays.copyOf(a, <span class=\"number\">10</span>);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;b.length&quot;</span>+b.length);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"两者联系和区别\"><a href=\"#两者联系和区别\" class=\"headerlink\" title=\"两者联系和区别\"></a>两者联系和区别</h4><p><strong>联系：</strong></p>\n<p>看两者源代码可以发现 <code>copyOf()</code>内部实际调用了 <code>System.arraycopy()</code> 方法</p>\n<p><strong>区别：</strong></p>\n<p><code>arraycopy()</code> 需要目标数组，将原数组拷贝到你自己定义的数组里或者原数组，而且可以选择拷贝的起点和长度以及放入新数组中的位置 <code>copyOf()</code> 是系统自动在内部新建一个数组，并返回该数组。</p>\n<h3 id=\"ensureCapacity方法\"><a href=\"#ensureCapacity方法\" class=\"headerlink\" title=\"ensureCapacity方法\"></a><code>ensureCapacity</code>方法</h3><p><code>ArrayList</code> 源码中有一个 <code>ensureCapacity</code> 方法不知道大家注意到没有，这个方法 <code>ArrayList</code> 内部没有被调用过，所以很显然是提供给用户调用的，那么这个方法有什么作用呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">如有必要，增加此 ArrayList 实例的容量，以确保它至少可以容纳由minimum capacity参数指定的元素数。</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span>   minCapacity   所需的最小容量</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">ensureCapacity</span><span class=\"params\">(<span class=\"type\">int</span> minCapacity)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">minExpand</span> <span class=\"operator\">=</span> (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class=\"line\">        <span class=\"comment\">// any size if not default element table</span></span><br><span class=\"line\">        ? <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"comment\">// larger than default for default empty table. It&#x27;s already</span></span><br><span class=\"line\">        <span class=\"comment\">// supposed to be at default size.</span></span><br><span class=\"line\">        : DEFAULT_CAPACITY;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class=\"line\">        ensureExplicitCapacity(minCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>理论上来说，最好在向 <code>ArrayList</code> 添加大量元素之前用 <code>ensureCapacity</code> 方法，以减少增量重新分配的次数</p>\n<p>我们通过下面的代码实际测试以下这个方法的效果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">EnsureCapacityTest</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    ArrayList&lt;Object&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;Object&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">N</span> <span class=\"operator\">=</span> <span class=\"number\">10000000</span>;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">startTime</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; N; i++) &#123;</span><br><span class=\"line\">      list.add(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">endTime</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;使用ensureCapacity方法前：&quot;</span>+(endTime - startTime));</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用ensureCapacity方法前：2158</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">EnsureCapacityTest</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        ArrayList&lt;Object&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;Object&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">N</span> <span class=\"operator\">=</span> <span class=\"number\">10000000</span>;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">startTime1</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">        list.ensureCapacity(N);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; N; i++) &#123;</span><br><span class=\"line\">            list.add(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">endTime1</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;使用ensureCapacity方法后：&quot;</span>+(endTime1 - startTime1));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用ensureCapacity方法后：1773</span><br></pre></td></tr></table></figure>\n\n<p>通过运行结果，我们可以看出向 <code>ArrayList</code> 添加大量元素之前使用<code>ensureCapacity</code> 方法可以提升性能。不过，这个性能差距几乎可以忽略不计。而且，实际项目根本也不可能往 <code>ArrayList</code> 里面添加这么多元素。</p>\n"},{"title":"什么是 RAG ?","date":"2025-12-27T09:07:20.000Z","math":true,"_content":"\n# RAG 概述\n\n## 一、引言\n\n**Retrieval-Augmented Generation (RAG)，即检索增强生成，是一种使用来自私有或专有数据源的信息来补充文本生成的技术**。用于优化大型语言模型（Large Language Models, LLMs）的输出性能。它通过将外部知识库与生成模型相结合，使模型能够在不重新训练的情况下访问特定领域或实时更新的信息，从而提升响应的准确性、相关性和可靠性。\n\nRAG 的核心在于桥接信息检索系统（如搜索和数据库）和生成模型的优势，允许模型从外部数据源中检索相关事实，并将其融入生成过程中。这使得\n\nRAG 特别适用于需要事实的应用场景，例如聊天机器人、企业知识管理系统或实时查询工具。\n\n---\n\n## 二、为什么要使用 RAG ？\n\n大语言模型（Large Language Models, LLMs）在自然语言理解与生成任务中展现出强大能力，但其固有局限性在**知识密集型（knowledge-intensive）场景**中尤为突出。为克服这些限制，**检索增强生成（RAG）** 被提出并广泛应用。其核心动因可归纳为以下三点：\n\n### 1. **缓解幻觉（Hallucination）问题**\n\nLLMs 本质上是基于统计模式生成文本，当面对训练数据中未覆盖或模糊的事实时，容易生成看似合理但**事实错误的内容**（即“幻觉”）。  \nRAG 通过在生成前从**可信外部知识源**（如企业文档库、维基百科、数据库）中检索相关证据，将生成过程锚定于真实信息，显著降低事实性错误率。\n\n### 2. **突破静态知识边界**\n\nLLMs 的知识截止于其训练数据的时间点（即“知识冻结”），无法获取**训练后的新事件、动态数据或私有领域知识**（如公司内部文档、用户个人资料）。  \nRAG 将语言模型与**可更新的外部知识库解耦**，使得系统无需重新训练即可：\n\n- 实时接入最新信息；\n- 定制化集成垂直领域专有数据；\n- 支持多租户场景下的个性化知识注入。\n\n### 3. **提升可解释性与可控性**\n\n在 RAG 架构中，生成结果可追溯至具体的检索证据（retrieved passages），这为系统提供了**天然的可解释性（explainability）**。  \n运维人员或用户可审查所用依据，判断答案可靠性；开发者亦可通过优化检索器（如调整召回策略、过滤低质量文档）**精细调控生成内容的质量与范围**，而无需修改复杂的语言模型本身。\n\n---\n\n### 说明：RAG 与微调（Fine-tuning）的对比\n\n| 维度         | 微调（Fine-tuning）    | RAG             |\n|------------|--------------------|-----------------|\n| **知识更新成本** | 高（需重新训练/部署模型）      | 低（仅更新知识库）       |\n| **私有知识支持** | 需将私有数据混入训练集，存在泄露风险 | 知识隔离，按需检索       |\n| **事实准确性**  | 依赖模型记忆，易过时或出错      | 依赖外部证据，实时准确     |\n| **适用场景**   | 任务风格适配（如语气、格式）     | 事实性问答、文档问答、知识推理 |\n\n> **RAG 并非替代微调，而是与其互补**：微调优化“如何说”，RAG 解决“说什么”。\n\n---\n\n## 三、RAG 的工作原理\n\nRAG（Retrieval-Augmented Generation）是一种**将信息检索与语言生成相结合的混合架构**\n。其核心思想是：在生成答案前，先从外部知识库中检索与用户查询最相关的文档片段，并将这些片段作为上下文输入给生成模型，从而引导其输出\n**事实准确、证据可溯**的回答。\n\n整个流程可分为两个阶段：**检索（Retrieval）** 与 **生成（Generation）**，如下图所示：\n\n```mermaid\nflowchart LR\n    A[\"用户查询\\n“巴黎的埃菲尔铁塔有多高？”\"] --> B{\"检索器\\n(Retriever)\"}\n    B --> C[\"知识库\\n(Knowledge Source)\"]\n    C --> D[\"Top-k 相关文档\\n• “埃菲尔铁塔高330米...”\\n• “建成于1889年...”\"]\n    A --> G[\"合并增强提示\"]\n    D --> G\n    G --> E{\"生成器\\n(Generator)\"}\n    E --> F[\"最终答案\\n“埃菲尔铁塔高330米。”\"]\n```\n\n### 1. 检索阶段（Retrieval）\n\n- **输入**：用户原始查询 $ q $。\n- **过程**：\n    - 查询 $ q $ 被编码为稠密向量（通常采用双塔架构模型，如 **DPR**（Dense Passage Retriever）或 **SBERT**）；\n    - 在**预先构建索引的外部知识库**（例如 Wikipedia、企业知识库或私有文档集合）中执行**近似最近邻搜索**（Approximate\n      Nearest Neighbor, ANN），召回与查询语义最相关的 Top-$k$ 个文档片段 $ \\{d_1, d_2, \\dots, d_k\\} $。\n- **输出**：一组作为证据支持的候选文档。\n\n> **注**：知识库通常以“嵌入向量 + 原始文本”形式存储。常用索引后端包括 **FAISS**、**Annoy** 或 **Elasticsearch**。\n\n---\n\n### 2. 生成阶段（Generation）\n\n- **输入**：原始查询 $ q $ 与检索得到的文档集合 $ \\{d_i\\}_{i=1}^k $ 被组合为结构化提示（prompt），例如：\n\n```text\n  文档：埃菲尔铁塔高330米，包括天线。\n  问题：巴黎的埃菲尔铁塔有多高？\n  答案：\n```\n\n- **过程**：\n    - 生成器（如 **T5**、**BART** 等 Seq2Seq 模型，或 **LLaMA**、**GPT** 等 Decoder-only 架构）基于该上下文生成自然语言答案；\n    - 该过程可建模为条件概率 $ P(a \\mid q, d_i) $，其中 $ a $ 为生成的答案。\n- **输出**：一个受检索证据约束、事实性更强的自然语言响应。\n\n---\n\n### 3. 形式化定义\n\nRAG 模型的目标是最大化以下**边际似然**（marginal likelihood）：\n\n$$\nP(a \\mid q) = \\sum_{d \\in \\mathcal{D}} P(d \\mid q) \\cdot P(a \\mid q, d)\n$$\n\n其中：\n\n- $ \\mathcal{D} $ 表示整个外部知识库；\n- $ P(d \\mid q) $ 由**检索器**（retriever）建模，反映文档 $ d $ 与查询 $ q $ 的相关性；\n- $ P(a \\mid q, d) $ 由**生成器**（generator）建模，表示在给定查询和文档条件下生成答案的概率。\n\n由于知识库 $ \\mathcal{D} $ 规模庞大（常达数百万至数十亿文档），实际计算中仅对 Top-$k$ 检索结果进行近似求和：\n\n$$\nP(a \\mid q) \\approx \\sum_{i=1}^{k} P(d_i \\mid q) \\cdot P(a \\mid q, d_i)\n$$\n\n---\n\n## 四、关键组件说明\n\n### 1. 知识库（Knowledge Source）\n\n**职责**\n- 存储用于检索的**结构化或非结构化文本数据**；\n- 作为事实性知识的来源，支撑问答、摘要、推理等任务。\n\n**数据形式**\n- **原始文档**：PDF、Word、网页、数据库记录、Markdown 文件等；\n- **预处理后片段**：通常被切分为固定长度（如 256–512 tokens）的文本块（chunks），以适配嵌入模型和上下文窗口。\n\n**典型构建流程**\n1. **数据采集**：从内部系统或公开源收集原始内容；\n2. **清洗与标准化**：去除噪声、统一编码、提取正文；\n3. **分块（Chunking）**：按语义边界（如段落、标题）或固定长度切分；\n4. **元数据标注（可选）**：添加来源 URL、作者、时间戳等，用于后续过滤或溯源。\n\n> **最佳实践**：避免跨语义边界的硬切分（如在句子中间截断）。\n\n---\n\n### 2. 检索器（Retriever）\n\n**职责**\n- 将用户查询 $ q $ 映射到知识库中最相关的文档片段集合 $ \\{d_i\\} $；\n- 平衡**召回率**（Recall）与**精度**（Precision）。\n\n**技术分类**\n\n| 类型 | 原理 | 代表方法 | 适用场景 |\n|------|------|--------|--------|\n| **稀疏检索** | 基于词频/TF-IDF 或 BM25 | Elasticsearch, Lucene | 关键词匹配强、无需训练 |\n| **稠密检索** | 基于向量相似度（如余弦） | DPR, SBERT, ColBERT | 语义匹配、支持同义/ paraphrase |\n| **混合检索** | 稀疏 + 稠密融合 | SPLADE + FAISS, Hybrid Search in Vespa | 高精度要求场景 |\n\n**核心子模块**\n- **查询编码器**（Query Encoder）：将 $ q $ 编码为向量 $ \\mathbf{q} \\in \\mathbb{R}^d $；\n- **文档编码器**（Document Encoder）：预先将所有文档块编码为向量并建立索引；\n- **索引系统**：支持高效 ANN 搜索，常用工具包括：\n  - **FAISS**（Facebook）：高性能 CPU/GPU 向量索引；\n  - **Annoy**（Spotify）：轻量级，适合中小规模；\n  - **Pinecone / Weaviate / Milvus**：托管向量数据库，支持过滤、更新、多租户。\n\n> **注意**：稠密检索需确保查询与文档使用**同一嵌入模型**，否则向量空间不一致导致性能下降或者直接无法查询。\n\n---\n\n### 3. 生成器（Generator）\n\n**职责**\n- 基于检索结果 $ \\{d_i\\} $ 与原始查询 $ q $，生成自然语言答案 $ a $；\n- 控制输出风格、长度、事实一致性。\n\n**模型类型**\n\n| 类型 | 特点 | 代表模型 | 是否需微调 |\n|------|------|--------|----------|\n| **Seq2Seq** | 编码器-解码器架构，天然支持条件生成 | T5, BART | 可端到端训练（如原始 RAG） |\n| **Decoder-only LLM** | 仅解码器，依赖 prompt 工程 | LLaMA, GPT, Qwen | 通常 zero-shot 使用 |\n\n**输入构造方式**\n生成器的输入通常为拼接后的提示（prompt）：\n```text \n[检索文档 1]\n[检索文档 2]\n...\n问题：{query}\n答案：\n```\n\n**输出控制**\n- **约束解码**：强制答案来自检索内容（如使用 `LLM + Reranker + Extractive Head`）；\n- **后处理校验**：通过 NLI 模型或规则检查幻觉。\n\n---\n\n### 组件协同工作流程\n\n```mermaid\nflowchart LR\n    A[\"用户查询 q\"] --> B{\"检索器\"}\n    B --> C[\"知识库\\n(分块 + 嵌入)\"]\n    C --> D[\"Top-k 文档 {d₁, …, dₖ}\"]\n    A --> G[\"增强提示\\n(query + retrieved docs)\"]\n    D --> G\n    G --> E{\"生成器\"}\n    E --> F[\"答案 a\"]\n```\n\n1. 用户发起查询 $ q $；\n2. 检索器从知识库中召回相关文档；\n3. 生成器融合 $ q $ 与 $ \\{d_i\\} $ 生成最终答案。\n\n---\n\n### 补充：可选增强组件\n\n| 组件 | 作用 |\n|------|------|\n| **重排序器**（Reranker） | 对 Top-$k$ 结果二次打分（如 Cohere Rerank, BGE-Reranker），提升 top-1 精度 |\n| **查询扩展/改写模块** | 将模糊查询转为明确形式（如 “它多高？” → “埃菲尔铁塔高度？”） |\n| **缓存层** | 缓存高频查询的检索结果，降低延迟与成本 |\n\n---","source":"_posts/RAG/introduceRAG.md","raw":"---\ntitle: 什么是 RAG ?\ncategories: [ RAG ]\ndate: 2025-12-27 17:07:20\ntags: [ RAG ]\npermalink: /RAG\nmath: true\n---\n\n# RAG 概述\n\n## 一、引言\n\n**Retrieval-Augmented Generation (RAG)，即检索增强生成，是一种使用来自私有或专有数据源的信息来补充文本生成的技术**。用于优化大型语言模型（Large Language Models, LLMs）的输出性能。它通过将外部知识库与生成模型相结合，使模型能够在不重新训练的情况下访问特定领域或实时更新的信息，从而提升响应的准确性、相关性和可靠性。\n\nRAG 的核心在于桥接信息检索系统（如搜索和数据库）和生成模型的优势，允许模型从外部数据源中检索相关事实，并将其融入生成过程中。这使得\n\nRAG 特别适用于需要事实的应用场景，例如聊天机器人、企业知识管理系统或实时查询工具。\n\n---\n\n## 二、为什么要使用 RAG ？\n\n大语言模型（Large Language Models, LLMs）在自然语言理解与生成任务中展现出强大能力，但其固有局限性在**知识密集型（knowledge-intensive）场景**中尤为突出。为克服这些限制，**检索增强生成（RAG）** 被提出并广泛应用。其核心动因可归纳为以下三点：\n\n### 1. **缓解幻觉（Hallucination）问题**\n\nLLMs 本质上是基于统计模式生成文本，当面对训练数据中未覆盖或模糊的事实时，容易生成看似合理但**事实错误的内容**（即“幻觉”）。  \nRAG 通过在生成前从**可信外部知识源**（如企业文档库、维基百科、数据库）中检索相关证据，将生成过程锚定于真实信息，显著降低事实性错误率。\n\n### 2. **突破静态知识边界**\n\nLLMs 的知识截止于其训练数据的时间点（即“知识冻结”），无法获取**训练后的新事件、动态数据或私有领域知识**（如公司内部文档、用户个人资料）。  \nRAG 将语言模型与**可更新的外部知识库解耦**，使得系统无需重新训练即可：\n\n- 实时接入最新信息；\n- 定制化集成垂直领域专有数据；\n- 支持多租户场景下的个性化知识注入。\n\n### 3. **提升可解释性与可控性**\n\n在 RAG 架构中，生成结果可追溯至具体的检索证据（retrieved passages），这为系统提供了**天然的可解释性（explainability）**。  \n运维人员或用户可审查所用依据，判断答案可靠性；开发者亦可通过优化检索器（如调整召回策略、过滤低质量文档）**精细调控生成内容的质量与范围**，而无需修改复杂的语言模型本身。\n\n---\n\n### 说明：RAG 与微调（Fine-tuning）的对比\n\n| 维度         | 微调（Fine-tuning）    | RAG             |\n|------------|--------------------|-----------------|\n| **知识更新成本** | 高（需重新训练/部署模型）      | 低（仅更新知识库）       |\n| **私有知识支持** | 需将私有数据混入训练集，存在泄露风险 | 知识隔离，按需检索       |\n| **事实准确性**  | 依赖模型记忆，易过时或出错      | 依赖外部证据，实时准确     |\n| **适用场景**   | 任务风格适配（如语气、格式）     | 事实性问答、文档问答、知识推理 |\n\n> **RAG 并非替代微调，而是与其互补**：微调优化“如何说”，RAG 解决“说什么”。\n\n---\n\n## 三、RAG 的工作原理\n\nRAG（Retrieval-Augmented Generation）是一种**将信息检索与语言生成相结合的混合架构**\n。其核心思想是：在生成答案前，先从外部知识库中检索与用户查询最相关的文档片段，并将这些片段作为上下文输入给生成模型，从而引导其输出\n**事实准确、证据可溯**的回答。\n\n整个流程可分为两个阶段：**检索（Retrieval）** 与 **生成（Generation）**，如下图所示：\n\n```mermaid\nflowchart LR\n    A[\"用户查询\\n“巴黎的埃菲尔铁塔有多高？”\"] --> B{\"检索器\\n(Retriever)\"}\n    B --> C[\"知识库\\n(Knowledge Source)\"]\n    C --> D[\"Top-k 相关文档\\n• “埃菲尔铁塔高330米...”\\n• “建成于1889年...”\"]\n    A --> G[\"合并增强提示\"]\n    D --> G\n    G --> E{\"生成器\\n(Generator)\"}\n    E --> F[\"最终答案\\n“埃菲尔铁塔高330米。”\"]\n```\n\n### 1. 检索阶段（Retrieval）\n\n- **输入**：用户原始查询 $ q $。\n- **过程**：\n    - 查询 $ q $ 被编码为稠密向量（通常采用双塔架构模型，如 **DPR**（Dense Passage Retriever）或 **SBERT**）；\n    - 在**预先构建索引的外部知识库**（例如 Wikipedia、企业知识库或私有文档集合）中执行**近似最近邻搜索**（Approximate\n      Nearest Neighbor, ANN），召回与查询语义最相关的 Top-$k$ 个文档片段 $ \\{d_1, d_2, \\dots, d_k\\} $。\n- **输出**：一组作为证据支持的候选文档。\n\n> **注**：知识库通常以“嵌入向量 + 原始文本”形式存储。常用索引后端包括 **FAISS**、**Annoy** 或 **Elasticsearch**。\n\n---\n\n### 2. 生成阶段（Generation）\n\n- **输入**：原始查询 $ q $ 与检索得到的文档集合 $ \\{d_i\\}_{i=1}^k $ 被组合为结构化提示（prompt），例如：\n\n```text\n  文档：埃菲尔铁塔高330米，包括天线。\n  问题：巴黎的埃菲尔铁塔有多高？\n  答案：\n```\n\n- **过程**：\n    - 生成器（如 **T5**、**BART** 等 Seq2Seq 模型，或 **LLaMA**、**GPT** 等 Decoder-only 架构）基于该上下文生成自然语言答案；\n    - 该过程可建模为条件概率 $ P(a \\mid q, d_i) $，其中 $ a $ 为生成的答案。\n- **输出**：一个受检索证据约束、事实性更强的自然语言响应。\n\n---\n\n### 3. 形式化定义\n\nRAG 模型的目标是最大化以下**边际似然**（marginal likelihood）：\n\n$$\nP(a \\mid q) = \\sum_{d \\in \\mathcal{D}} P(d \\mid q) \\cdot P(a \\mid q, d)\n$$\n\n其中：\n\n- $ \\mathcal{D} $ 表示整个外部知识库；\n- $ P(d \\mid q) $ 由**检索器**（retriever）建模，反映文档 $ d $ 与查询 $ q $ 的相关性；\n- $ P(a \\mid q, d) $ 由**生成器**（generator）建模，表示在给定查询和文档条件下生成答案的概率。\n\n由于知识库 $ \\mathcal{D} $ 规模庞大（常达数百万至数十亿文档），实际计算中仅对 Top-$k$ 检索结果进行近似求和：\n\n$$\nP(a \\mid q) \\approx \\sum_{i=1}^{k} P(d_i \\mid q) \\cdot P(a \\mid q, d_i)\n$$\n\n---\n\n## 四、关键组件说明\n\n### 1. 知识库（Knowledge Source）\n\n**职责**\n- 存储用于检索的**结构化或非结构化文本数据**；\n- 作为事实性知识的来源，支撑问答、摘要、推理等任务。\n\n**数据形式**\n- **原始文档**：PDF、Word、网页、数据库记录、Markdown 文件等；\n- **预处理后片段**：通常被切分为固定长度（如 256–512 tokens）的文本块（chunks），以适配嵌入模型和上下文窗口。\n\n**典型构建流程**\n1. **数据采集**：从内部系统或公开源收集原始内容；\n2. **清洗与标准化**：去除噪声、统一编码、提取正文；\n3. **分块（Chunking）**：按语义边界（如段落、标题）或固定长度切分；\n4. **元数据标注（可选）**：添加来源 URL、作者、时间戳等，用于后续过滤或溯源。\n\n> **最佳实践**：避免跨语义边界的硬切分（如在句子中间截断）。\n\n---\n\n### 2. 检索器（Retriever）\n\n**职责**\n- 将用户查询 $ q $ 映射到知识库中最相关的文档片段集合 $ \\{d_i\\} $；\n- 平衡**召回率**（Recall）与**精度**（Precision）。\n\n**技术分类**\n\n| 类型 | 原理 | 代表方法 | 适用场景 |\n|------|------|--------|--------|\n| **稀疏检索** | 基于词频/TF-IDF 或 BM25 | Elasticsearch, Lucene | 关键词匹配强、无需训练 |\n| **稠密检索** | 基于向量相似度（如余弦） | DPR, SBERT, ColBERT | 语义匹配、支持同义/ paraphrase |\n| **混合检索** | 稀疏 + 稠密融合 | SPLADE + FAISS, Hybrid Search in Vespa | 高精度要求场景 |\n\n**核心子模块**\n- **查询编码器**（Query Encoder）：将 $ q $ 编码为向量 $ \\mathbf{q} \\in \\mathbb{R}^d $；\n- **文档编码器**（Document Encoder）：预先将所有文档块编码为向量并建立索引；\n- **索引系统**：支持高效 ANN 搜索，常用工具包括：\n  - **FAISS**（Facebook）：高性能 CPU/GPU 向量索引；\n  - **Annoy**（Spotify）：轻量级，适合中小规模；\n  - **Pinecone / Weaviate / Milvus**：托管向量数据库，支持过滤、更新、多租户。\n\n> **注意**：稠密检索需确保查询与文档使用**同一嵌入模型**，否则向量空间不一致导致性能下降或者直接无法查询。\n\n---\n\n### 3. 生成器（Generator）\n\n**职责**\n- 基于检索结果 $ \\{d_i\\} $ 与原始查询 $ q $，生成自然语言答案 $ a $；\n- 控制输出风格、长度、事实一致性。\n\n**模型类型**\n\n| 类型 | 特点 | 代表模型 | 是否需微调 |\n|------|------|--------|----------|\n| **Seq2Seq** | 编码器-解码器架构，天然支持条件生成 | T5, BART | 可端到端训练（如原始 RAG） |\n| **Decoder-only LLM** | 仅解码器，依赖 prompt 工程 | LLaMA, GPT, Qwen | 通常 zero-shot 使用 |\n\n**输入构造方式**\n生成器的输入通常为拼接后的提示（prompt）：\n```text \n[检索文档 1]\n[检索文档 2]\n...\n问题：{query}\n答案：\n```\n\n**输出控制**\n- **约束解码**：强制答案来自检索内容（如使用 `LLM + Reranker + Extractive Head`）；\n- **后处理校验**：通过 NLI 模型或规则检查幻觉。\n\n---\n\n### 组件协同工作流程\n\n```mermaid\nflowchart LR\n    A[\"用户查询 q\"] --> B{\"检索器\"}\n    B --> C[\"知识库\\n(分块 + 嵌入)\"]\n    C --> D[\"Top-k 文档 {d₁, …, dₖ}\"]\n    A --> G[\"增强提示\\n(query + retrieved docs)\"]\n    D --> G\n    G --> E{\"生成器\"}\n    E --> F[\"答案 a\"]\n```\n\n1. 用户发起查询 $ q $；\n2. 检索器从知识库中召回相关文档；\n3. 生成器融合 $ q $ 与 $ \\{d_i\\} $ 生成最终答案。\n\n---\n\n### 补充：可选增强组件\n\n| 组件 | 作用 |\n|------|------|\n| **重排序器**（Reranker） | 对 Top-$k$ 结果二次打分（如 Cohere Rerank, BGE-Reranker），提升 top-1 精度 |\n| **查询扩展/改写模块** | 将模糊查询转为明确形式（如 “它多高？” → “埃菲尔铁塔高度？”） |\n| **缓存层** | 缓存高频查询的检索结果，降低延迟与成本 |\n\n---","slug":"RAG/introduceRAG","published":1,"updated":"2025-12-27T14:14:48.408Z","__permalink":"/RAG","comments":1,"layout":"post","photos":[],"_id":"cuidWGe3q8OZqtMV-qX5oga18","content":"<h1 id=\"RAG-概述\"><a href=\"#RAG-概述\" class=\"headerlink\" title=\"RAG 概述\"></a>RAG 概述</h1><h2 id=\"一、引言\"><a href=\"#一、引言\" class=\"headerlink\" title=\"一、引言\"></a>一、引言</h2><p><strong>Retrieval-Augmented Generation (RAG)，即检索增强生成，是一种使用来自私有或专有数据源的信息来补充文本生成的技术</strong>。用于优化大型语言模型（Large Language Models, LLMs）的输出性能。它通过将外部知识库与生成模型相结合，使模型能够在不重新训练的情况下访问特定领域或实时更新的信息，从而提升响应的准确性、相关性和可靠性。</p>\n<p>RAG 的核心在于桥接信息检索系统（如搜索和数据库）和生成模型的优势，允许模型从外部数据源中检索相关事实，并将其融入生成过程中。这使得</p>\n<p>RAG 特别适用于需要事实的应用场景，例如聊天机器人、企业知识管理系统或实时查询工具。</p>\n<hr>\n<h2 id=\"二、为什么要使用-RAG-？\"><a href=\"#二、为什么要使用-RAG-？\" class=\"headerlink\" title=\"二、为什么要使用 RAG ？\"></a>二、为什么要使用 RAG ？</h2><p>大语言模型（Large Language Models, LLMs）在自然语言理解与生成任务中展现出强大能力，但其固有局限性在<strong>知识密集型（knowledge-intensive）场景</strong>中尤为突出。为克服这些限制，<strong>检索增强生成（RAG）</strong> 被提出并广泛应用。其核心动因可归纳为以下三点：</p>\n<h3 id=\"1-缓解幻觉（Hallucination）问题\"><a href=\"#1-缓解幻觉（Hallucination）问题\" class=\"headerlink\" title=\"1. 缓解幻觉（Hallucination）问题\"></a>1. <strong>缓解幻觉（Hallucination）问题</strong></h3><p>LLMs 本质上是基于统计模式生成文本，当面对训练数据中未覆盖或模糊的事实时，容易生成看似合理但<strong>事实错误的内容</strong>（即“幻觉”）。<br>RAG 通过在生成前从<strong>可信外部知识源</strong>（如企业文档库、维基百科、数据库）中检索相关证据，将生成过程锚定于真实信息，显著降低事实性错误率。</p>\n<h3 id=\"2-突破静态知识边界\"><a href=\"#2-突破静态知识边界\" class=\"headerlink\" title=\"2. 突破静态知识边界\"></a>2. <strong>突破静态知识边界</strong></h3><p>LLMs 的知识截止于其训练数据的时间点（即“知识冻结”），无法获取<strong>训练后的新事件、动态数据或私有领域知识</strong>（如公司内部文档、用户个人资料）。<br>RAG 将语言模型与<strong>可更新的外部知识库解耦</strong>，使得系统无需重新训练即可：</p>\n<ul>\n<li>实时接入最新信息；</li>\n<li>定制化集成垂直领域专有数据；</li>\n<li>支持多租户场景下的个性化知识注入。</li>\n</ul>\n<h3 id=\"3-提升可解释性与可控性\"><a href=\"#3-提升可解释性与可控性\" class=\"headerlink\" title=\"3. 提升可解释性与可控性\"></a>3. <strong>提升可解释性与可控性</strong></h3><p>在 RAG 架构中，生成结果可追溯至具体的检索证据（retrieved passages），这为系统提供了<strong>天然的可解释性（explainability）</strong>。<br>运维人员或用户可审查所用依据，判断答案可靠性；开发者亦可通过优化检索器（如调整召回策略、过滤低质量文档）<strong>精细调控生成内容的质量与范围</strong>，而无需修改复杂的语言模型本身。</p>\n<hr>\n<h3 id=\"说明：RAG-与微调（Fine-tuning）的对比\"><a href=\"#说明：RAG-与微调（Fine-tuning）的对比\" class=\"headerlink\" title=\"说明：RAG 与微调（Fine-tuning）的对比\"></a>说明：RAG 与微调（Fine-tuning）的对比</h3><table>\n<thead>\n<tr>\n<th>维度</th>\n<th>微调（Fine-tuning）</th>\n<th>RAG</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>知识更新成本</strong></td>\n<td>高（需重新训练&#x2F;部署模型）</td>\n<td>低（仅更新知识库）</td>\n</tr>\n<tr>\n<td><strong>私有知识支持</strong></td>\n<td>需将私有数据混入训练集，存在泄露风险</td>\n<td>知识隔离，按需检索</td>\n</tr>\n<tr>\n<td><strong>事实准确性</strong></td>\n<td>依赖模型记忆，易过时或出错</td>\n<td>依赖外部证据，实时准确</td>\n</tr>\n<tr>\n<td><strong>适用场景</strong></td>\n<td>任务风格适配（如语气、格式）</td>\n<td>事实性问答、文档问答、知识推理</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>RAG 并非替代微调，而是与其互补</strong>：微调优化“如何说”，RAG 解决“说什么”。</p>\n</blockquote>\n<hr>\n<h2 id=\"三、RAG-的工作原理\"><a href=\"#三、RAG-的工作原理\" class=\"headerlink\" title=\"三、RAG 的工作原理\"></a>三、RAG 的工作原理</h2><p>RAG（Retrieval-Augmented Generation）是一种<strong>将信息检索与语言生成相结合的混合架构</strong><br>。其核心思想是：在生成答案前，先从外部知识库中检索与用户查询最相关的文档片段，并将这些片段作为上下文输入给生成模型，从而引导其输出<br><strong>事实准确、证据可溯</strong>的回答。</p>\n<p>整个流程可分为两个阶段：<strong>检索（Retrieval）</strong> 与 <strong>生成（Generation）</strong>，如下图所示：</p>\n<pre class=\"mermaid\">flowchart LR\n    A[\"用户查询\\n“巴黎的埃菲尔铁塔有多高？”\"] --> B{\"检索器\\n(Retriever)\"}\n    B --> C[\"知识库\\n(Knowledge Source)\"]\n    C --> D[\"Top-k 相关文档\\n• “埃菲尔铁塔高330米...”\\n• “建成于1889年...”\"]\n    A --> G[\"合并增强提示\"]\n    D --> G\n    G --> E{\"生成器\\n(Generator)\"}\n    E --> F[\"最终答案\\n“埃菲尔铁塔高330米。”\"]</pre>\n\n<h3 id=\"1-检索阶段（Retrieval）\"><a href=\"#1-检索阶段（Retrieval）\" class=\"headerlink\" title=\"1. 检索阶段（Retrieval）\"></a>1. 检索阶段（Retrieval）</h3><ul>\n<li><strong>输入</strong>：用户原始查询 $ q $。</li>\n<li><strong>过程</strong>：<ul>\n<li>查询 $ q $ 被编码为稠密向量（通常采用双塔架构模型，如 <strong>DPR</strong>（Dense Passage Retriever）或 <strong>SBERT</strong>）；</li>\n<li>在<strong>预先构建索引的外部知识库</strong>（例如 Wikipedia、企业知识库或私有文档集合）中执行<strong>近似最近邻搜索</strong>（Approximate<br>Nearest Neighbor, ANN），召回与查询语义最相关的 Top-$k$ 个文档片段 $ {d_1, d_2, \\dots, d_k} $。</li>\n</ul>\n</li>\n<li><strong>输出</strong>：一组作为证据支持的候选文档。</li>\n</ul>\n<blockquote>\n<p><strong>注</strong>：知识库通常以“嵌入向量 + 原始文本”形式存储。常用索引后端包括 <strong>FAISS</strong>、<strong>Annoy</strong> 或 <strong>Elasticsearch</strong>。</p>\n</blockquote>\n<hr>\n<h3 id=\"2-生成阶段（Generation）\"><a href=\"#2-生成阶段（Generation）\" class=\"headerlink\" title=\"2. 生成阶段（Generation）\"></a>2. 生成阶段（Generation）</h3><ul>\n<li><strong>输入</strong>：原始查询 $ q $ 与检索得到的文档集合 $ {d_i}_{i&#x3D;1}^k $ 被组合为结构化提示（prompt），例如：</li>\n</ul>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">文档：埃菲尔铁塔高330米，包括天线。</span><br><span class=\"line\">问题：巴黎的埃菲尔铁塔有多高？</span><br><span class=\"line\">答案：</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>过程</strong>：<ul>\n<li>生成器（如 <strong>T5</strong>、<strong>BART</strong> 等 Seq2Seq 模型，或 <strong>LLaMA</strong>、<strong>GPT</strong> 等 Decoder-only 架构）基于该上下文生成自然语言答案；</li>\n<li>该过程可建模为条件概率 $ P(a \\mid q, d_i) $，其中 $ a $ 为生成的答案。</li>\n</ul>\n</li>\n<li><strong>输出</strong>：一个受检索证据约束、事实性更强的自然语言响应。</li>\n</ul>\n<hr>\n<h3 id=\"3-形式化定义\"><a href=\"#3-形式化定义\" class=\"headerlink\" title=\"3. 形式化定义\"></a>3. 形式化定义</h3><p>RAG 模型的目标是最大化以下<strong>边际似然</strong>（marginal likelihood）：</p>\n<p>$$<br>P(a \\mid q) &#x3D; \\sum_{d \\in \\mathcal{D}} P(d \\mid q) \\cdot P(a \\mid q, d)<br>$$</p>\n<p>其中：</p>\n<ul>\n<li>$ \\mathcal{D} $ 表示整个外部知识库；</li>\n<li>$ P(d \\mid q) $ 由<strong>检索器</strong>（retriever）建模，反映文档 $ d $ 与查询 $ q $ 的相关性；</li>\n<li>$ P(a \\mid q, d) $ 由<strong>生成器</strong>（generator）建模，表示在给定查询和文档条件下生成答案的概率。</li>\n</ul>\n<p>由于知识库 $ \\mathcal{D} $ 规模庞大（常达数百万至数十亿文档），实际计算中仅对 Top-$k$ 检索结果进行近似求和：</p>\n<p>$$<br>P(a \\mid q) \\approx \\sum_{i&#x3D;1}^{k} P(d_i \\mid q) \\cdot P(a \\mid q, d_i)<br>$$</p>\n<hr>\n<h2 id=\"四、关键组件说明\"><a href=\"#四、关键组件说明\" class=\"headerlink\" title=\"四、关键组件说明\"></a>四、关键组件说明</h2><h3 id=\"1-知识库（Knowledge-Source）\"><a href=\"#1-知识库（Knowledge-Source）\" class=\"headerlink\" title=\"1. 知识库（Knowledge Source）\"></a>1. 知识库（Knowledge Source）</h3><p><strong>职责</strong></p>\n<ul>\n<li>存储用于检索的<strong>结构化或非结构化文本数据</strong>；</li>\n<li>作为事实性知识的来源，支撑问答、摘要、推理等任务。</li>\n</ul>\n<p><strong>数据形式</strong></p>\n<ul>\n<li><strong>原始文档</strong>：PDF、Word、网页、数据库记录、Markdown 文件等；</li>\n<li><strong>预处理后片段</strong>：通常被切分为固定长度（如 256–512 tokens）的文本块（chunks），以适配嵌入模型和上下文窗口。</li>\n</ul>\n<p><strong>典型构建流程</strong></p>\n<ol>\n<li><strong>数据采集</strong>：从内部系统或公开源收集原始内容；</li>\n<li><strong>清洗与标准化</strong>：去除噪声、统一编码、提取正文；</li>\n<li><strong>分块（Chunking）</strong>：按语义边界（如段落、标题）或固定长度切分；</li>\n<li><strong>元数据标注（可选）</strong>：添加来源 URL、作者、时间戳等，用于后续过滤或溯源。</li>\n</ol>\n<blockquote>\n<p><strong>最佳实践</strong>：避免跨语义边界的硬切分（如在句子中间截断）。</p>\n</blockquote>\n<hr>\n<h3 id=\"2-检索器（Retriever）\"><a href=\"#2-检索器（Retriever）\" class=\"headerlink\" title=\"2. 检索器（Retriever）\"></a>2. 检索器（Retriever）</h3><p><strong>职责</strong></p>\n<ul>\n<li>将用户查询 $ q $ 映射到知识库中最相关的文档片段集合 $ {d_i} $；</li>\n<li>平衡<strong>召回率</strong>（Recall）与<strong>精度</strong>（Precision）。</li>\n</ul>\n<p><strong>技术分类</strong></p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>原理</th>\n<th>代表方法</th>\n<th>适用场景</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>稀疏检索</strong></td>\n<td>基于词频&#x2F;TF-IDF 或 BM25</td>\n<td>Elasticsearch, Lucene</td>\n<td>关键词匹配强、无需训练</td>\n</tr>\n<tr>\n<td><strong>稠密检索</strong></td>\n<td>基于向量相似度（如余弦）</td>\n<td>DPR, SBERT, ColBERT</td>\n<td>语义匹配、支持同义&#x2F; paraphrase</td>\n</tr>\n<tr>\n<td><strong>混合检索</strong></td>\n<td>稀疏 + 稠密融合</td>\n<td>SPLADE + FAISS, Hybrid Search in Vespa</td>\n<td>高精度要求场景</td>\n</tr>\n</tbody></table>\n<p><strong>核心子模块</strong></p>\n<ul>\n<li><strong>查询编码器</strong>（Query Encoder）：将 $ q $ 编码为向量 $ \\mathbf{q} \\in \\mathbb{R}^d $；</li>\n<li><strong>文档编码器</strong>（Document Encoder）：预先将所有文档块编码为向量并建立索引；</li>\n<li><strong>索引系统</strong>：支持高效 ANN 搜索，常用工具包括：<ul>\n<li><strong>FAISS</strong>（Facebook）：高性能 CPU&#x2F;GPU 向量索引；</li>\n<li><strong>Annoy</strong>（Spotify）：轻量级，适合中小规模；</li>\n<li><strong>Pinecone &#x2F; Weaviate &#x2F; Milvus</strong>：托管向量数据库，支持过滤、更新、多租户。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p><strong>注意</strong>：稠密检索需确保查询与文档使用<strong>同一嵌入模型</strong>，否则向量空间不一致导致性能下降或者直接无法查询。</p>\n</blockquote>\n<hr>\n<h3 id=\"3-生成器（Generator）\"><a href=\"#3-生成器（Generator）\" class=\"headerlink\" title=\"3. 生成器（Generator）\"></a>3. 生成器（Generator）</h3><p><strong>职责</strong></p>\n<ul>\n<li>基于检索结果 $ {d_i} $ 与原始查询 $ q $，生成自然语言答案 $ a $；</li>\n<li>控制输出风格、长度、事实一致性。</li>\n</ul>\n<p><strong>模型类型</strong></p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>特点</th>\n<th>代表模型</th>\n<th>是否需微调</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Seq2Seq</strong></td>\n<td>编码器-解码器架构，天然支持条件生成</td>\n<td>T5, BART</td>\n<td>可端到端训练（如原始 RAG）</td>\n</tr>\n<tr>\n<td><strong>Decoder-only LLM</strong></td>\n<td>仅解码器，依赖 prompt 工程</td>\n<td>LLaMA, GPT, Qwen</td>\n<td>通常 zero-shot 使用</td>\n</tr>\n</tbody></table>\n<p><strong>输入构造方式</strong><br>生成器的输入通常为拼接后的提示（prompt）：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[检索文档 1]</span><br><span class=\"line\">[检索文档 2]</span><br><span class=\"line\">...</span><br><span class=\"line\">问题：&#123;query&#125;</span><br><span class=\"line\">答案：</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出控制</strong></p>\n<ul>\n<li><strong>约束解码</strong>：强制答案来自检索内容（如使用 <code>LLM + Reranker + Extractive Head</code>）；</li>\n<li><strong>后处理校验</strong>：通过 NLI 模型或规则检查幻觉。</li>\n</ul>\n<hr>\n<h3 id=\"组件协同工作流程\"><a href=\"#组件协同工作流程\" class=\"headerlink\" title=\"组件协同工作流程\"></a>组件协同工作流程</h3><pre class=\"mermaid\">flowchart LR\n    A[\"用户查询 q\"] --> B{\"检索器\"}\n    B --> C[\"知识库\\n(分块 + 嵌入)\"]\n    C --> D[\"Top-k 文档 {d₁, …, dₖ}\"]\n    A --> G[\"增强提示\\n(query + retrieved docs)\"]\n    D --> G\n    G --> E{\"生成器\"}\n    E --> F[\"答案 a\"]</pre>\n\n<ol>\n<li>用户发起查询 $ q $；</li>\n<li>检索器从知识库中召回相关文档；</li>\n<li>生成器融合 $ q $ 与 $ {d_i} $ 生成最终答案。</li>\n</ol>\n<hr>\n<h3 id=\"补充：可选增强组件\"><a href=\"#补充：可选增强组件\" class=\"headerlink\" title=\"补充：可选增强组件\"></a>补充：可选增强组件</h3><table>\n<thead>\n<tr>\n<th>组件</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>重排序器</strong>（Reranker）</td>\n<td>对 Top-$k$ 结果二次打分（如 Cohere Rerank, BGE-Reranker），提升 top-1 精度</td>\n</tr>\n<tr>\n<td><strong>查询扩展&#x2F;改写模块</strong></td>\n<td>将模糊查询转为明确形式（如 “它多高？” → “埃菲尔铁塔高度？”）</td>\n</tr>\n<tr>\n<td><strong>缓存层</strong></td>\n<td>缓存高频查询的检索结果，降低延迟与成本</td>\n</tr>\n</tbody></table>\n<hr>\n","excerpt":"","more":"<h1 id=\"RAG-概述\"><a href=\"#RAG-概述\" class=\"headerlink\" title=\"RAG 概述\"></a>RAG 概述</h1><h2 id=\"一、引言\"><a href=\"#一、引言\" class=\"headerlink\" title=\"一、引言\"></a>一、引言</h2><p><strong>Retrieval-Augmented Generation (RAG)，即检索增强生成，是一种使用来自私有或专有数据源的信息来补充文本生成的技术</strong>。用于优化大型语言模型（Large Language Models, LLMs）的输出性能。它通过将外部知识库与生成模型相结合，使模型能够在不重新训练的情况下访问特定领域或实时更新的信息，从而提升响应的准确性、相关性和可靠性。</p>\n<p>RAG 的核心在于桥接信息检索系统（如搜索和数据库）和生成模型的优势，允许模型从外部数据源中检索相关事实，并将其融入生成过程中。这使得</p>\n<p>RAG 特别适用于需要事实的应用场景，例如聊天机器人、企业知识管理系统或实时查询工具。</p>\n<hr>\n<h2 id=\"二、为什么要使用-RAG-？\"><a href=\"#二、为什么要使用-RAG-？\" class=\"headerlink\" title=\"二、为什么要使用 RAG ？\"></a>二、为什么要使用 RAG ？</h2><p>大语言模型（Large Language Models, LLMs）在自然语言理解与生成任务中展现出强大能力，但其固有局限性在<strong>知识密集型（knowledge-intensive）场景</strong>中尤为突出。为克服这些限制，<strong>检索增强生成（RAG）</strong> 被提出并广泛应用。其核心动因可归纳为以下三点：</p>\n<h3 id=\"1-缓解幻觉（Hallucination）问题\"><a href=\"#1-缓解幻觉（Hallucination）问题\" class=\"headerlink\" title=\"1. 缓解幻觉（Hallucination）问题\"></a>1. <strong>缓解幻觉（Hallucination）问题</strong></h3><p>LLMs 本质上是基于统计模式生成文本，当面对训练数据中未覆盖或模糊的事实时，容易生成看似合理但<strong>事实错误的内容</strong>（即“幻觉”）。<br>RAG 通过在生成前从<strong>可信外部知识源</strong>（如企业文档库、维基百科、数据库）中检索相关证据，将生成过程锚定于真实信息，显著降低事实性错误率。</p>\n<h3 id=\"2-突破静态知识边界\"><a href=\"#2-突破静态知识边界\" class=\"headerlink\" title=\"2. 突破静态知识边界\"></a>2. <strong>突破静态知识边界</strong></h3><p>LLMs 的知识截止于其训练数据的时间点（即“知识冻结”），无法获取<strong>训练后的新事件、动态数据或私有领域知识</strong>（如公司内部文档、用户个人资料）。<br>RAG 将语言模型与<strong>可更新的外部知识库解耦</strong>，使得系统无需重新训练即可：</p>\n<ul>\n<li>实时接入最新信息；</li>\n<li>定制化集成垂直领域专有数据；</li>\n<li>支持多租户场景下的个性化知识注入。</li>\n</ul>\n<h3 id=\"3-提升可解释性与可控性\"><a href=\"#3-提升可解释性与可控性\" class=\"headerlink\" title=\"3. 提升可解释性与可控性\"></a>3. <strong>提升可解释性与可控性</strong></h3><p>在 RAG 架构中，生成结果可追溯至具体的检索证据（retrieved passages），这为系统提供了<strong>天然的可解释性（explainability）</strong>。<br>运维人员或用户可审查所用依据，判断答案可靠性；开发者亦可通过优化检索器（如调整召回策略、过滤低质量文档）<strong>精细调控生成内容的质量与范围</strong>，而无需修改复杂的语言模型本身。</p>\n<hr>\n<h3 id=\"说明：RAG-与微调（Fine-tuning）的对比\"><a href=\"#说明：RAG-与微调（Fine-tuning）的对比\" class=\"headerlink\" title=\"说明：RAG 与微调（Fine-tuning）的对比\"></a>说明：RAG 与微调（Fine-tuning）的对比</h3><table>\n<thead>\n<tr>\n<th>维度</th>\n<th>微调（Fine-tuning）</th>\n<th>RAG</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>知识更新成本</strong></td>\n<td>高（需重新训练&#x2F;部署模型）</td>\n<td>低（仅更新知识库）</td>\n</tr>\n<tr>\n<td><strong>私有知识支持</strong></td>\n<td>需将私有数据混入训练集，存在泄露风险</td>\n<td>知识隔离，按需检索</td>\n</tr>\n<tr>\n<td><strong>事实准确性</strong></td>\n<td>依赖模型记忆，易过时或出错</td>\n<td>依赖外部证据，实时准确</td>\n</tr>\n<tr>\n<td><strong>适用场景</strong></td>\n<td>任务风格适配（如语气、格式）</td>\n<td>事实性问答、文档问答、知识推理</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>RAG 并非替代微调，而是与其互补</strong>：微调优化“如何说”，RAG 解决“说什么”。</p>\n</blockquote>\n<hr>\n<h2 id=\"三、RAG-的工作原理\"><a href=\"#三、RAG-的工作原理\" class=\"headerlink\" title=\"三、RAG 的工作原理\"></a>三、RAG 的工作原理</h2><p>RAG（Retrieval-Augmented Generation）是一种<strong>将信息检索与语言生成相结合的混合架构</strong><br>。其核心思想是：在生成答案前，先从外部知识库中检索与用户查询最相关的文档片段，并将这些片段作为上下文输入给生成模型，从而引导其输出<br><strong>事实准确、证据可溯</strong>的回答。</p>\n<p>整个流程可分为两个阶段：<strong>检索（Retrieval）</strong> 与 <strong>生成（Generation）</strong>，如下图所示：</p>\n<pre class=\"mermaid\">flowchart LR\n    A[\"用户查询\\n“巴黎的埃菲尔铁塔有多高？”\"] --> B{\"检索器\\n(Retriever)\"}\n    B --> C[\"知识库\\n(Knowledge Source)\"]\n    C --> D[\"Top-k 相关文档\\n• “埃菲尔铁塔高330米...”\\n• “建成于1889年...”\"]\n    A --> G[\"合并增强提示\"]\n    D --> G\n    G --> E{\"生成器\\n(Generator)\"}\n    E --> F[\"最终答案\\n“埃菲尔铁塔高330米。”\"]</pre>\n\n<h3 id=\"1-检索阶段（Retrieval）\"><a href=\"#1-检索阶段（Retrieval）\" class=\"headerlink\" title=\"1. 检索阶段（Retrieval）\"></a>1. 检索阶段（Retrieval）</h3><ul>\n<li><strong>输入</strong>：用户原始查询 $ q $。</li>\n<li><strong>过程</strong>：<ul>\n<li>查询 $ q $ 被编码为稠密向量（通常采用双塔架构模型，如 <strong>DPR</strong>（Dense Passage Retriever）或 <strong>SBERT</strong>）；</li>\n<li>在<strong>预先构建索引的外部知识库</strong>（例如 Wikipedia、企业知识库或私有文档集合）中执行<strong>近似最近邻搜索</strong>（Approximate<br>Nearest Neighbor, ANN），召回与查询语义最相关的 Top-$k$ 个文档片段 $ {d_1, d_2, \\dots, d_k} $。</li>\n</ul>\n</li>\n<li><strong>输出</strong>：一组作为证据支持的候选文档。</li>\n</ul>\n<blockquote>\n<p><strong>注</strong>：知识库通常以“嵌入向量 + 原始文本”形式存储。常用索引后端包括 <strong>FAISS</strong>、<strong>Annoy</strong> 或 <strong>Elasticsearch</strong>。</p>\n</blockquote>\n<hr>\n<h3 id=\"2-生成阶段（Generation）\"><a href=\"#2-生成阶段（Generation）\" class=\"headerlink\" title=\"2. 生成阶段（Generation）\"></a>2. 生成阶段（Generation）</h3><ul>\n<li><strong>输入</strong>：原始查询 $ q $ 与检索得到的文档集合 $ {d_i}_{i&#x3D;1}^k $ 被组合为结构化提示（prompt），例如：</li>\n</ul>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">文档：埃菲尔铁塔高330米，包括天线。</span><br><span class=\"line\">问题：巴黎的埃菲尔铁塔有多高？</span><br><span class=\"line\">答案：</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>过程</strong>：<ul>\n<li>生成器（如 <strong>T5</strong>、<strong>BART</strong> 等 Seq2Seq 模型，或 <strong>LLaMA</strong>、<strong>GPT</strong> 等 Decoder-only 架构）基于该上下文生成自然语言答案；</li>\n<li>该过程可建模为条件概率 $ P(a \\mid q, d_i) $，其中 $ a $ 为生成的答案。</li>\n</ul>\n</li>\n<li><strong>输出</strong>：一个受检索证据约束、事实性更强的自然语言响应。</li>\n</ul>\n<hr>\n<h3 id=\"3-形式化定义\"><a href=\"#3-形式化定义\" class=\"headerlink\" title=\"3. 形式化定义\"></a>3. 形式化定义</h3><p>RAG 模型的目标是最大化以下<strong>边际似然</strong>（marginal likelihood）：</p>\n<p>$$<br>P(a \\mid q) &#x3D; \\sum_{d \\in \\mathcal{D}} P(d \\mid q) \\cdot P(a \\mid q, d)<br>$$</p>\n<p>其中：</p>\n<ul>\n<li>$ \\mathcal{D} $ 表示整个外部知识库；</li>\n<li>$ P(d \\mid q) $ 由<strong>检索器</strong>（retriever）建模，反映文档 $ d $ 与查询 $ q $ 的相关性；</li>\n<li>$ P(a \\mid q, d) $ 由<strong>生成器</strong>（generator）建模，表示在给定查询和文档条件下生成答案的概率。</li>\n</ul>\n<p>由于知识库 $ \\mathcal{D} $ 规模庞大（常达数百万至数十亿文档），实际计算中仅对 Top-$k$ 检索结果进行近似求和：</p>\n<p>$$<br>P(a \\mid q) \\approx \\sum_{i&#x3D;1}^{k} P(d_i \\mid q) \\cdot P(a \\mid q, d_i)<br>$$</p>\n<hr>\n<h2 id=\"四、关键组件说明\"><a href=\"#四、关键组件说明\" class=\"headerlink\" title=\"四、关键组件说明\"></a>四、关键组件说明</h2><h3 id=\"1-知识库（Knowledge-Source）\"><a href=\"#1-知识库（Knowledge-Source）\" class=\"headerlink\" title=\"1. 知识库（Knowledge Source）\"></a>1. 知识库（Knowledge Source）</h3><p><strong>职责</strong></p>\n<ul>\n<li>存储用于检索的<strong>结构化或非结构化文本数据</strong>；</li>\n<li>作为事实性知识的来源，支撑问答、摘要、推理等任务。</li>\n</ul>\n<p><strong>数据形式</strong></p>\n<ul>\n<li><strong>原始文档</strong>：PDF、Word、网页、数据库记录、Markdown 文件等；</li>\n<li><strong>预处理后片段</strong>：通常被切分为固定长度（如 256–512 tokens）的文本块（chunks），以适配嵌入模型和上下文窗口。</li>\n</ul>\n<p><strong>典型构建流程</strong></p>\n<ol>\n<li><strong>数据采集</strong>：从内部系统或公开源收集原始内容；</li>\n<li><strong>清洗与标准化</strong>：去除噪声、统一编码、提取正文；</li>\n<li><strong>分块（Chunking）</strong>：按语义边界（如段落、标题）或固定长度切分；</li>\n<li><strong>元数据标注（可选）</strong>：添加来源 URL、作者、时间戳等，用于后续过滤或溯源。</li>\n</ol>\n<blockquote>\n<p><strong>最佳实践</strong>：避免跨语义边界的硬切分（如在句子中间截断）。</p>\n</blockquote>\n<hr>\n<h3 id=\"2-检索器（Retriever）\"><a href=\"#2-检索器（Retriever）\" class=\"headerlink\" title=\"2. 检索器（Retriever）\"></a>2. 检索器（Retriever）</h3><p><strong>职责</strong></p>\n<ul>\n<li>将用户查询 $ q $ 映射到知识库中最相关的文档片段集合 $ {d_i} $；</li>\n<li>平衡<strong>召回率</strong>（Recall）与<strong>精度</strong>（Precision）。</li>\n</ul>\n<p><strong>技术分类</strong></p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>原理</th>\n<th>代表方法</th>\n<th>适用场景</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>稀疏检索</strong></td>\n<td>基于词频&#x2F;TF-IDF 或 BM25</td>\n<td>Elasticsearch, Lucene</td>\n<td>关键词匹配强、无需训练</td>\n</tr>\n<tr>\n<td><strong>稠密检索</strong></td>\n<td>基于向量相似度（如余弦）</td>\n<td>DPR, SBERT, ColBERT</td>\n<td>语义匹配、支持同义&#x2F; paraphrase</td>\n</tr>\n<tr>\n<td><strong>混合检索</strong></td>\n<td>稀疏 + 稠密融合</td>\n<td>SPLADE + FAISS, Hybrid Search in Vespa</td>\n<td>高精度要求场景</td>\n</tr>\n</tbody></table>\n<p><strong>核心子模块</strong></p>\n<ul>\n<li><strong>查询编码器</strong>（Query Encoder）：将 $ q $ 编码为向量 $ \\mathbf{q} \\in \\mathbb{R}^d $；</li>\n<li><strong>文档编码器</strong>（Document Encoder）：预先将所有文档块编码为向量并建立索引；</li>\n<li><strong>索引系统</strong>：支持高效 ANN 搜索，常用工具包括：<ul>\n<li><strong>FAISS</strong>（Facebook）：高性能 CPU&#x2F;GPU 向量索引；</li>\n<li><strong>Annoy</strong>（Spotify）：轻量级，适合中小规模；</li>\n<li><strong>Pinecone &#x2F; Weaviate &#x2F; Milvus</strong>：托管向量数据库，支持过滤、更新、多租户。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p><strong>注意</strong>：稠密检索需确保查询与文档使用<strong>同一嵌入模型</strong>，否则向量空间不一致导致性能下降或者直接无法查询。</p>\n</blockquote>\n<hr>\n<h3 id=\"3-生成器（Generator）\"><a href=\"#3-生成器（Generator）\" class=\"headerlink\" title=\"3. 生成器（Generator）\"></a>3. 生成器（Generator）</h3><p><strong>职责</strong></p>\n<ul>\n<li>基于检索结果 $ {d_i} $ 与原始查询 $ q $，生成自然语言答案 $ a $；</li>\n<li>控制输出风格、长度、事实一致性。</li>\n</ul>\n<p><strong>模型类型</strong></p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>特点</th>\n<th>代表模型</th>\n<th>是否需微调</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Seq2Seq</strong></td>\n<td>编码器-解码器架构，天然支持条件生成</td>\n<td>T5, BART</td>\n<td>可端到端训练（如原始 RAG）</td>\n</tr>\n<tr>\n<td><strong>Decoder-only LLM</strong></td>\n<td>仅解码器，依赖 prompt 工程</td>\n<td>LLaMA, GPT, Qwen</td>\n<td>通常 zero-shot 使用</td>\n</tr>\n</tbody></table>\n<p><strong>输入构造方式</strong><br>生成器的输入通常为拼接后的提示（prompt）：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[检索文档 1]</span><br><span class=\"line\">[检索文档 2]</span><br><span class=\"line\">...</span><br><span class=\"line\">问题：&#123;query&#125;</span><br><span class=\"line\">答案：</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出控制</strong></p>\n<ul>\n<li><strong>约束解码</strong>：强制答案来自检索内容（如使用 <code>LLM + Reranker + Extractive Head</code>）；</li>\n<li><strong>后处理校验</strong>：通过 NLI 模型或规则检查幻觉。</li>\n</ul>\n<hr>\n<h3 id=\"组件协同工作流程\"><a href=\"#组件协同工作流程\" class=\"headerlink\" title=\"组件协同工作流程\"></a>组件协同工作流程</h3><pre class=\"mermaid\">flowchart LR\n    A[\"用户查询 q\"] --> B{\"检索器\"}\n    B --> C[\"知识库\\n(分块 + 嵌入)\"]\n    C --> D[\"Top-k 文档 {d₁, …, dₖ}\"]\n    A --> G[\"增强提示\\n(query + retrieved docs)\"]\n    D --> G\n    G --> E{\"生成器\"}\n    E --> F[\"答案 a\"]</pre>\n\n<ol>\n<li>用户发起查询 $ q $；</li>\n<li>检索器从知识库中召回相关文档；</li>\n<li>生成器融合 $ q $ 与 $ {d_i} $ 生成最终答案。</li>\n</ol>\n<hr>\n<h3 id=\"补充：可选增强组件\"><a href=\"#补充：可选增强组件\" class=\"headerlink\" title=\"补充：可选增强组件\"></a>补充：可选增强组件</h3><table>\n<thead>\n<tr>\n<th>组件</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>重排序器</strong>（Reranker）</td>\n<td>对 Top-$k$ 结果二次打分（如 Cohere Rerank, BGE-Reranker），提升 top-1 精度</td>\n</tr>\n<tr>\n<td><strong>查询扩展&#x2F;改写模块</strong></td>\n<td>将模糊查询转为明确形式（如 “它多高？” → “埃菲尔铁塔高度？”）</td>\n</tr>\n<tr>\n<td><strong>缓存层</strong></td>\n<td>缓存高频查询的检索结果，降低延迟与成本</td>\n</tr>\n</tbody></table>\n<hr>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cuidWGe3q8OZqtMV-qX5oga18","category_id":"cuidJdx6lKUygRevtyUT1rud9","_id":"cuid9xVnV5zGVSdBptrFg5ASm"},{"post_id":"cuid5GMpqeHLyCaHHNFwvFduH","category_id":"cuideyTbsvPYcPCgcgGqvpbSY","_id":"cuidPXyjmxvjWUDpf7IhXS5V9"},{"post_id":"cuid5GMpqeHLyCaHHNFwvFduH","category_id":"cuidNpz3u01UfoQFYuOP1TQxi","_id":"cuidm2soffKCmiIJlpGo7UfZ2"}],"PostTag":[{"post_id":"cuid5GMpqeHLyCaHHNFwvFduH","tag_id":"cuidqqsyDBmaRyX0mgHNqGWfC","_id":"cuidZygloJSmJVl6yumjcKlaA"},{"post_id":"cuid5GMpqeHLyCaHHNFwvFduH","tag_id":"cuid1VZVV4OpU23fYcXhhBA1_","_id":"cuidc0GMA29jkgknZmDb9AX9U"},{"post_id":"cuidWGe3q8OZqtMV-qX5oga18","tag_id":"cuid0GPbh_t2W_XSiGGWHqfON","_id":"cuidEp_3Rt-fVeuZ_E5LJ-GXs"}],"Tag":[{"name":"Java","_id":"cuidqqsyDBmaRyX0mgHNqGWfC"},{"name":"collection","_id":"cuid1VZVV4OpU23fYcXhhBA1_"},{"name":"RAG","_id":"cuid0GPbh_t2W_XSiGGWHqfON"}]}}